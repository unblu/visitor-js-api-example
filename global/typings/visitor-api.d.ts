// Generated by dts-bundle v0.7.3

declare module 'unblu' {
    import { UnbluStaticApi } from 'unblu/unblu-static-api';
    import { CallState } from 'unblu/model/call-state';
    import { ConnectionState } from 'unblu/model/connection-state';
    import { ConversationType } from 'unblu/model/conversation-type';
    import { AgentAvailabilityState } from 'unblu/model/agent-availability-state';
    import { ConversationState } from 'unblu/model/conversation-state';
    export { UnbluApi } from 'unblu/unblu-api';
    export { Conversation } from 'unblu/conversation';
    /**
        * The main unblu namespace which gives access to the unblu api.
        *
        * Access:
        * ```javascript
        * window.unblu.api;
        * ```
        *
        * **Note:** all fields inside the unblu namespace except for the [[api]] are not public and may change without any notice.
        */
    export interface Unblu {
            /**
                * Access to the unblu API.
                *
                * This field will be available as soon as the unblu API has been loaded.
                */
            api?: UnbluStaticApi;
            AgentAvailabilityState?: typeof AgentAvailabilityState;
            CallState?: typeof CallState;
            ConnectionState?: typeof ConnectionState;
            ConversationState?: typeof ConversationState;
            ConversationType?: typeof ConversationType;
    }
    /**
        * Global window scope definition of the unblu namespace on the window.
        * Access:
        * ```javascript
        * window.unblu.api;
        * ```
        */
    global {
            interface Window {
                    /**
                        * The main unblu namespace
                        */
                    unblu: Unblu;
            }
    }
    /**
        * The central access point to the unblu JS API.
        * This api object gives static access to configure and initialize the full unblu `UnbluApi`.
        * When loaded in the global space use `Unblu.Api` to access it.
        * @hidden
        */
    export const api: UnbluStaticApi;
}

declare module 'unblu/unblu-static-api' {
    import { UnbluApi } from 'unblu/unblu-api';
    import { Listener } from 'unblu/internal/util/event-emitter';
    export interface Configuration {
            /**
                * An API-Key of the account to be used.
                * This is a mandatory configuration.
                *
                * API keys can be retrieved from the unblu Agent Desk in the settings section.
                * Keep in mind, that an Admin role is needed.
                */
            apiKey: string;
            /**
                * The url of the unblu server to connect to.
                *
                * @default If not set, the domain of the current page will be used.
                */
            serverUrl?: string;
            /**
                * The public path to unblu which will be used in combination with [[serverUrl]] to connect to unblu.
                *
                * @default If not set, '/unblu' will be used.
                */
            entryPath?: string;
            /**
                * The locale to be used for all unblu translation texts.
                *
                * @default If not set, the browsers locale will be used.
                */
            locale?: string;
            /**
                * The named area to be used. The named area determines the agent availability, the queue that conversation requests go to, and the configuration.
                *
                * @default If not set, if the `<meta name="unblu:named-area" content="<your-named-area>"/>` will be used if present and if not, the domain will be used.
                */
            namedArea?: string;
            /**
                * The timeout im milliseconds that should be waited for the unblu integration to load.
                *
                * @default 30'000 (30 seconds).
                */
            initTimeout?: number;
    }
    export const enum ApiState {
            INITIAL = "INITIAL",
            INITIALIZING = "INITIALIZING",
            INITIALIZED = "INITIALIZED",
            ERROR = "ERROR"
    }
    export type ReadyListener = (api: UnbluApi) => void;
    export type ErrorListener = (e: Error) => void;
    /**
        * #### The central entry point that allows to configure an initialize the unblu JS API.
        * The static unblu API works without actually loading the rest of unblu.
        * It can do some general checks and load unblu or connect the API to a loaded version of unblu.
        * The JS API is an optional add-on to the unblu visitor site integration.
        *
        * Depending on how unblu is integrated into the local website the API has to be initialized differently.
        *
        * **a.) API-only integration**
        * If no unblu-snippet is loaded into the page, unblu can be fully initialized with the API.
        * In this case, both the `configure` and the `initialize` methods have to be called.
        * Example:
        * ```ts
        *  const api = await unblu.api
        *      // configure the unblu server
        *      .configure({
        *          apiKey: "<your-api-key>",
        *          serverUrl: "<unblu-server-url>"
        *      })
        *      // initialize the api.
        *      .initialize();
        * ```
        * This implementation will load the unblu snippet and initialize both unblu and the JS API.
        *
        * **b.) Snippet and JS API integration**
        * If the unblu-snippet is already present in the local website, unblu doesn't have to be loaded
        * and only the API has to be initialized.
        * Example:
        * ```ts
        * // directly initialize the api without configuring.
        * const api = await unblu.api.initialize();
        *
        * ```
        */
    export class UnbluStaticApi {
            /**
                * Event emitted as soon as the API is initialized.
                *
                * It usually makes sense to use this event if there is some general action that has to be triggered when the API is initialized,
                * but there are several places in the integration code that may trigger the initialization.
                *
                * In most cases however, it is better to use
                * ```ts
                * unblu.api.initialize().then(api => { //use api here });
                * ```
                * or
                * ```ts
                * let api = await unblu.api.initialize();
                * // use api here
                * ```
                *
                * @event ready
                * @see [[on]] for listener registration
                */
            static readonly READY: 'ready';
            /**
                * Event emitted if the API initialization fails.
                *
                * It usually makes sense to use this event if there is some general action that has to be triggered when the API initialization fails,
                * but there are several places in the integration code that may trigger the initialization.
                *
                * In most cases however, it is better to use
                * ```ts
                * unblu.api.initialize().catch(error=> { //handle error here });
                * ```
                * or
                * ```ts
                * try{
                *      let api = await unblu.api.initialize();
                * }catch(e){
                *     // handle error here
                * }
                *
                * ```
                *
                * @event error
                * @see [[on]] for listener registration
                */
            static readonly ERROR: 'error';
            /**
                * @hidden
                */
            constructor();
            /**
                * Registers an event listener for the given event.
                *
                * **Note** If the API is already initialized, this listener will be called directly.
                * @param event The ready event
                * @param listener The listener to be called.
                * @see [[READY]]
                */
            on(event: typeof UnbluStaticApi.READY, listener: ReadyListener): void;
            /**
                * Registers an event listener for the given event.
                *
                * **Note** If the API has already failed, this listener will be called directly.
                * @param event The error event
                * @param listener The listener to be called.
                * @see [[ERROR]]
                */
            on(event: typeof UnbluStaticApi.ERROR, listener: ErrorListener): void;
            /**
                * Removes a previously registered listener.
                * @param event The event unregister.
                * @param listener The listener to be removed.
                * @return `true` if the listener was removed, `false` otherwise.
                */
            off(event: string, listener: Listener): boolean;
            /**
                * Checks whether the API has to be configured or not.
                *
                * - If no snippet is present and the API state is still [[ApiState.INITIAL]] a configuration is necessary.
                * - If a snippet is present or the API is already loaded, configuration is not necessary.
                *
                * @return `true` if a configuration is needed to initialize the API, `false` otherwise.
                * @see [[configure]] to configure the API
                * @see [[initialize]] to initialize the API
                */
            isConfigurationNeeded(): boolean;
            /**
                * Returns the current state of the API
                * @return the current API state.
                * @see [[isInitialized]] for a simpler check
                */
            getApiState(): ApiState;
            /**
                * Checks whether the API is initialized or not.
                * @return `true` if the API is initialzed, `false` for any other state.
                * @see [[getApiState]] for the full state
                */
            isInitialized(): boolean;
            /**
                * Configures the way that unblu should be initialized.
                *
                * The configuration of the unblu API is needed when, and only when no unblu snippet is already present in the website.
                *
                * **Note:**
                * - Calling this method when there already is an unblu-snippet will result in an [[UnbluApiError]].
                * - This method must be called BEFORE [[initialize]]. If it is called afterwards an [[UnbluApiError]] will be thrown.
                *
                * @param config The configuration to be set.
                * @return an instance of `this` allowing chaining like `unblu.api.configure({...}).initialize();`
                * @see [[isConfigurationNeeded]] to check if configuration is needed or not.
                */
            configure(config: Configuration): UnbluStaticApi;
            /**
                * Initializes the API and resolves to the fully initialized API.
                *
                * If the API has already been initialized or is already in the initializing process, the existing API will be returned.
                * There is only ever one instance of the API which will be returned by any call of this method which makes it safe to call this multiple times.
                *
                * *The initialization may fail with a [[UnbluApiError]] for the following reasons*
                * - A configuration is needed but none was provided: [[UnbluErrorCategory.INITIALIZATION_FAILED]]
                * - The initialization timed out: [[UnbluErrorCategory.INITIALIZATION_FAILED]]
                * - The unblu API is incompatible with the unblu server: [[UnbluErrorCategory.INCOMPATIBLE_UNBLU_VERSION]]
                * - The browser is unsupported: [[UnbluErrorCategory.UNSUPPORTED_BROWSER]]
                */
            initialize(): Promise<UnbluApi>;
    }
}

declare module 'unblu/model/call-state' {
    export enum CallState {
            /**
                * A some one is trying to call, the phone is ringing
                */
            INBOUND = "INBOUND",
            /**
                * You are trying to call someone
                */
            OUTBOUND = "OUTBOUND",
            /**
                * A call is active and the local tab is connected to the call.
                */
            ACTIVE_JOINED = "ACTIVE_JOINED",
            /**
                * A call is active but the local person has declined it.
                */
            ACTIVE_NOT_JOINED = "ACTIVE_NOT_JOINED",
            /**
                * A call is active and the local person has joined it on an other device.
                */
            ACTIVE_JOINED_ELSEWHERE = "ACTIVE_JOINED_ELSEWHERE",
            /**
                * No inbound, outgoing or active call.
                */
            NONE = "NONE"
    }
}

declare module 'unblu/model/connection-state' {
    export enum ConnectionState {
            /**
                * Initial state before connection establishment has started
                */
            INITIAL = "INITIAL",
            /**
                * State during the first connection to the server
                */
            CONNECTING = "CONNECTING",
            /**
                * The connection has been successfully established.
                */
            CONNECTED = "CONNECTED",
            /**
                * The connection has been lost, reconnect is active.
                */
            RECONNECTING = "RECONNECTING",
            /**
                * The connection has been successfully closed.
                *
                */
            CLOSED = "CLOSED",
            /**
                * A fatal error has occurred. The connection has been permanently lost. No reconnect will be be possible.
                */
            ERROR = "ERROR"
    }
}

declare module 'unblu/model/conversation-type' {
    export enum ConversationType {
        CHAT_REQUEST = "CHAT_REQUEST",
        OFFLINE_CHAT_REQUEST = "OFFLINE_CHAT_REQUEST",
        VIDEO_REQUEST = "VIDEO_REQUEST",
        AUDIO_REQUEST = "AUDIO_REQUEST",
        HEADLESS_BROWSER_REQUEST = "HEADLESS_BROWSER_REQUEST",
        DOMCAP_BROWSER_REQUEST = "DOMCAP_BROWSER_REQUEST",
        MOBILE_COBROWSING_REQUEST = "MOBILE_COBROWSING_REQUEST"
    }
}

declare module 'unblu/model/agent-availability-state' {
    export enum AgentAvailabilityState {
            /**
                * There is at least one agent available for the specified named area and language.
                */
            AVAILABLE = "AVAILABLE",
            /**
                * There is at least one agent watching the inbound queue for the specified named area and language but the max capacity of pararallel conversations is reached.
                *
                * It is very likely, that an agent will be available in a short time.
                */
            BUSY = "BUSY",
            /**
                * There is no agent watching the inbound queue for the specified named area and language.
                *
                * It is unlikely, that an agent will be available in a short time.
                */
            UNAVAILABLE = "UNAVAILABLE",
            /**
                * There is currently no agent handling any inbound queue items.
                *
                * It is very unlikely, that an agent will be available in a short time.
                */
            OFFLINE = "OFFLINE"
    }
}

declare module 'unblu/model/conversation-state' {
    export enum ConversationState {
            /**
                * The conversation is active
                */
            OPEN = "OPEN",
            /**
                * The conversation has been ended. No further collaboration is possible.
                */
            ENDED = "ENDED"
    }
}

declare module 'unblu/unblu-api' {
    import { InternalApi } from 'unblu/internal/internal-api';
    import { GeneralEventType } from 'unblu/internal/module/general-module';
    import { Conversation } from 'unblu/conversation';
    import { PersonInfo } from 'unblu/model/person-info';
    import { Listener } from 'unblu/internal/util/event-emitter';
    import { ConversationType } from 'unblu/model/conversation-type';
    import { AgentAvailabilityState } from 'unblu/model/agent-availability-state';
    import { AgentAvailabilityEventType } from 'unblu/internal/module/agent-availability-module';
    /**
        * Listener called whenever the active conversation changes.
        *
        * **Note:** If no conversation is currently active the passed conversation object will be `null`
        * @param conversation API object for the active conversation or `null` if no conversation is active.
        */
    export type ConversationChangeListener = (conversation?: Conversation) => void;
    /**
        * Listener called whenever the notification count of a person (i.e. unread messages) changes.
        * @param count The number of unseen notifications.
        */
    export type NotificationCountChangeListener = (count: number) => void;
    /**
        * Listener called whenever the local person changes.
        * @param person Info about the person.
        */
    export type PersonChangeListener = (person: PersonInfo) => void;
    /**
        * Listener called whenever the agent availability changes.
        * @param availability The new availability.
        */
    export type AgentAvailabilityChangeListener = (availability: AgentAvailabilityState) => void;
    /**
        * #### This class represents the initialized unblu JS API for site integration.
        *
        * There is only ever one instance of this api which can be retrieved via `unblu.api.initialize()`,
        * see [[UnbluStaticApi]] for more details on configuring and initializing the UnbluApi.
        *
        * The Api connects to a integrated version of unblu. All actions performed via the UnbluApi are executed in
        * the name of and with the rights of current visitor and may have direct effect on the displayed unblu UI.
        *
        * For example if a conversation is started from the UnbluApi, the unblu UI will navigate to it.
        * If a conversation is closed via the Api, it will also be closed on the unblu UI of the visitor.
        * For more information on UI side effects please check the documentation for each method call.
        *
        *  For programmatic admin access and configuration of unblu please use the unblu WebApi.
        */
    export class UnbluApi {
            /**
                * Event emitted every time the active conversation changed.
                *
                * This may happen due to a UI-navigation or an API-call.
                *
                * @event activeConversationChange
                * @see [[on]] for listener registration
                * @see [[ConversationChangeListener]]
                */
            static readonly ACTIVE_CONVERSATION_CHANGE: 'activeConversationChange';
            /**
                * Event emitted every time the notification count (unread messages) changes.
                *
                * @event notificationCountChange
                * @see [[on]] for listener registration
                * @see [[NotificationCountChangeListener]]
                */
            static readonly NOTIFICATION_COUNT_CHANGE: 'notificationCountChange';
            /**
                * Event emitted every time the local person changes. This may be i.e. due to the person setting its name.
                *
                * @event personChange
                * @see [[on]] for listener registration
                * @see [[PersonChangeListener]]
                */
            static readonly PERSON_CHANGE: 'personChange';
            /**
                * Event emitted every time the agent availability changes for the current named area and locale.
                *
                * @event availabilityChange
                * @see [[on]] for listener registration
                * @see [[AgentAvailabilityChangeListener]]
                */
            static readonly AGENT_AVAILABILITY_CHANGE: 'availabilityChange';
            /**
                * @hidden
                */
            constructor(internalApi: InternalApi);
            /**
                * Registers an event listener for the given event.
                * @param event The activeConversationChange event.
                * @param listener The listener to be called.
                * @see [[ACTIVE_CONVERSATION_CHANGE]]
                */
            on(event: typeof UnbluApi.ACTIVE_CONVERSATION_CHANGE, listener: ConversationChangeListener): void;
            /**
                * Registers an event listener for the given event.
                * @param event The notificationCountChange event.
                * @param listener The listener to be called.
                * @see [[NOTIFICATION_COUNT_CHANGE]]
                */
            on(event: typeof UnbluApi.NOTIFICATION_COUNT_CHANGE, listener: NotificationCountChangeListener): void;
            /**
                * Registers an event listener for the given event.
                * @param event The personChange event.
                * @param listener The listener to be called.
                * @see [[PERSON_CHANGE]]
                */
            on(event: typeof UnbluApi.PERSON_CHANGE, listener: PersonChangeListener): void;
            /**
                * Registers an event listener for the given event.
                * @param event The personChange event.
                * @param listener The listener to be called.
                * @see [[PERSON_CHANGE]]
                */
            on(event: typeof UnbluApi.AGENT_AVAILABILITY_CHANGE, listener: AgentAvailabilityChangeListener): void;
            /**
                * Removes a previously registered listener
                * @param event The event to unregister from.
                * @param listener The listener to remove.
                */
            off(event: GeneralEventType | AgentAvailabilityEventType, listener: Listener): boolean;
            /**
                * Returns information about the visitor.
                * @return A promise that resolves to the current visitors person info.
                */
            getPersonInfo(): Promise<PersonInfo>;
            /**
                * Returns the number of unread messages.
                * @return A promise that resolves to the current number of unread messages.
                */
            getNotificationCount(): Promise<number>;
            /**
                * Starts a new Conversation and places it into the inbound conversation queue.
                *
                * **NOTE:** calling this method will open the unblu UI and navigate to the started conversation.
                *
                * @param type The conversation type that shall be started.
                * @param visitorName The name the local visitor should have. This is only taken into account if the visitor is not already authenticated.
                * @return A promise that resolves to the conversation object giving API access to the started conversation.
                */
            startConversation(type: ConversationType, visitorName?: string): Promise<Conversation>;
            /**
                * Joins an existing conversation with a given PIN.
                *
                * **NOTE:** calling this method will open the unblu UI and navigate to the joined conversation.
                *
                * @param pin The PIN retrieved from tha unblu Agent Desk.
                * @param visitorName The name the local visitor should have. This is only taken into account if the visitor is not already authenticated.
                * @return A promise that resolves to the conversation object giving API access to the joined conversation.
                */
            joinConversation(pin: string, visitorName?: string): Promise<Conversation>;
            /**
                * Opens the existing conversation with the given conversation ID.
                *
                * **NOTE:** calling this method will open the unblu UI and navigate to the opened conversation.
                *
                * @param conversationId The PIN retrieved from tha unblu Agent Desk.
                * @return A promise that resolves to the conversation object giving API access to the opened conversation.
                */
            openConversation(conversationId: string): Promise<Conversation>;
            /**
                * Returns the currently active conversation or `null` if no conversation is active.
                *
                * **NOTE:** calling this method twice while the same conversation is active, will result in two individual conversation API instances being returned.
                * destroying one of them will not cause the other one to also be destroyed. If however the active conversation is closed, all returned Conversation instances will be destroyed.
                *
                * @return A promise that either resolves to the currently active conversation or `null` if no conversation is open.
                * @see [[ACTIVE_CONVERSATION_CHANGE]]
                */
            getActiveConversation(): Promise<Conversation>;
            /**
                * Checks if an agent is available for the current named area and language.
                *
                * @return Promise that resolves to `true` if the availability state is [AVAILABLE](AgentAvailabilityState.AVAILABLE) or [BUSY](AgentAvailabilityState.BUSY), `false` otherwise.
                * @see [[getAgentAvailabilityState]] for a more detailed check.
                */
            isAgentAvailable(): Promise<boolean>;
            /**
                * Returns the current availability state for the current named area and language.
                * @return Promise that resolves to the current availability state.
                * @see [[isAgentAvailable]] for a simpler check.
                */
            getAgentAvailabilityState(): Promise<AgentAvailabilityState>;
    }
}

declare module 'unblu/conversation' {
    import { InternalApi } from 'unblu/internal/internal-api';
    import { CallState } from 'unblu/model/call-state';
    import { ConversationEventType } from 'unblu/internal/module/conversation-module';
    import { Listener } from 'unblu/internal/util/event-emitter';
    import { ConversationState } from 'unblu/model/conversation-state';
    import { ConnectionState } from 'unblu/model/connection-state';
    export type ConnectionStateListener = (connectionState: ConnectionState) => void;
    export type CallStateListener = (callState: CallState) => void;
    /**
        * #### This class gives API access to the currently active conversation.
        *
        * As long as a conversation is active one can register and receive the events provided by this class and call the methods.
        * Once the conversation is closed this API object will be destroyed and no more event callbacks will be called.
        * Any subsequent calls will fail.
        *
        * Use the [[CLOSE]] event to de-init any code connected to this conversation.
        */
    export class Conversation {
            /**
                * Event emitted when the [[ConnectionState]] of this conversation changes.
                * @event connectionStateChange
                * @see [[on]] for listener registration
                */
            static readonly CONNECTION_STATE_CHANGE: 'connectionStateChange';
            /**
                * Event emitted when the [[CallState]] of this conversation changes.
                * @event callStateChange
                * @see [[on]] for listener registration
                */
            static readonly CALL_STATE_CHANGE: 'callStateChange';
            /**
                * Event emitted when the conversation ends.
                *
                * @event end
                * @see [[on]] for listener registration
                */
            static readonly END: 'end';
            /**
                * Event emitted when the conversation is closed.
                *
                * This may happen due to a UI-navigation or an API-call.
                *
                * @event close
                * @see [[on]] for listener registration
                */
            static readonly CLOSE: 'close';
            /**
                * @hidden
                */
            constructor(internalApi: InternalApi, conversationId: string);
            /**
                * Registers an event listener for the given event.
                * @param event The call state change event.
                * @param listener The listener to be called.
                * @see [[CONNECTION_STATE_CHANGE]]
                */
            on(event: typeof Conversation.CONNECTION_STATE_CHANGE, listener: ConnectionStateListener): void;
            /**
                * Registers an event listener for the given event.
                * @param event The call state change event.
                * @param listener The listener to be called.
                * @see [[CALL_STATE_CHANGE]]
                */
            on(event: typeof Conversation.CALL_STATE_CHANGE, listener: CallStateListener): void;
            /**
                * Registers an event listener for the given event.
                * @param event The end event.
                * @param listener The listener to be called.
                * @see [[END]]
                */
            on(event: typeof Conversation.END, listener: () => void): void;
            /**
                * Registers an event listener for the given event.
                * @param event The close event.
                * @param listener The listener to be called.
                * @see [[CLOSE]]
                */
            on(event: typeof Conversation.CLOSE, listener: () => void): void;
            /**
                * Removes a previously registered listener
                * @param event The event to unregister from.
                * @param listener The listener to remove.
                */
            off(event: ConversationEventType, listener: Listener): boolean;
            /**
                * Returns the ID of this conversation.
                */
            getConversationId(): string;
            /**
                * Returns the current connection state the conversation is in.
                *
                * If the connection is lost, the conversation will automatically try to reconnect using an exponential back-off strategy.
                * If a fatal error is detected, the state will change to [[ConnectionState.ERROR]].
                *
                * If this happens, the conversation is in it's terminal state. A dialog or other UI will be displayed to the user with details on the failure.
                * The conversation is not automatically closed in this case.
                * It may either be closed through a manual action by the visitor (confirming the error) or via the API.
                *
                * @see [[CONNECTION_STATE_CHANGE]] If you need to listen to changes.
                * @return A promise that resolves to the current connection state of the conversation
                * or is rejected with a [[UnbluApiError]] if the call fails.
                */
            getConnectionState(): Promise<ConnectionState>;
            /**
                * Returns the current state the conversation is in.
                * @see [[END]]  If you need to listen to changes of the end event.
                * @return A promise that resolves to the current state of the conversation
                * or is rejected with a [[UnbluApiError]] if the call fails.
                */
            getConversationState(): Promise<ConversationState>;
            /**
                * @see [[CALL_STATE_CHANGE]] If you need to listen to changes.
                * @return A promise that resolves to the current call state of the local user
                * or is rejected with a [[UnbluApiError]] if the call fails.
                */
            getCallState(): Promise<CallState>;
            /**
                * Starts a voice call in this conversation.
                *
                * - If a call is already active, this call will be ignored.
                * - If the local person doesn't have the right to start a voice call,
                * the returned promise will be rejected with the unblu error category [[UnbluErrorCategory.ACTION_NOT_GRANTED]].
                * @see [[CALL_STATE_CHANGE]] If you need to listen to changes.
                * @return A Promise that resolves to null or is rejected with a [[UnbluApiError]] if the call fails.
                */
            startAudioCall(): Promise<void>;
            /**
                * Starts a video call in this conversation.
                *
                * - If a call is already active, this call will be ignored.
                * - If the local person doesn't have the right to start a video call,
                * the returned promise will be rejected with the unblu error category [[UnbluErrorCategory.ACTION_NOT_GRANTED]].
                * @see [[CALL_STATE_CHANGE]] If you need to listen to changes.
                * @return A Promise that resolves to null or is rejected with a [[UnbluApiError]] if the call fails.
                */
            startVideoCall(): Promise<void>;
            /**
                * Ends and closes this conversation.
                *
                * If the local person doesn't have the right to end the conversation,
                * the returned promise will be rejected with the unblu error category [[UnbluErrorCategory.ACTION_NOT_GRANTED]].
                * @see [[END]] fired after this call.
                * @see [[closeConversation]] for details on closing a conversation.
                * @return A Promise that resolves to null or is rejected with a [[UnbluApiError]] if the call fails.
                */
            endConversation(): Promise<void>;
            /**
                * Leaves and closes this conversation.
                *
                * By leaving, the visitor is removed from the active participant list of the conversation.
                * Once a conversation is left, the visitor can not re-open it. It will not be visible in the conversation history either.
                *
                * If the local person doesn't have the right to leave the conversation,
                * the returned promise will be rejected with the unblu error category [[UnbluErrorCategory.ACTION_NOT_GRANTED]].
                * @see [[CLOSE]] fired after this call.
                * @see [[closeConversation]] for details on closing a conversation without leaving.
                * @return A Promise that resolves to null or is rejected with a [[UnbluApiError]] if the call fails.
                */
            leaveConversation(): Promise<void>;
            /**
                * Closes this conversation locally.
                *
                * When called, the connection to this conversation is closed and the overview is displayed.
                *
                * **Note that:**
                * - Closing does NOT end the conversation.
                * - The person does NOT leave the conversation.
                * - All Conversation api instances for this conversation will be destroyed.
                *
                * The conversation can be joined again either via the UI or using [[UnbluApi.openConversation]].
                * @see [[CLOSE]] fired after this call.
                * @see [[endConversation]] for details on ending a conversation.
                * @see [[leavingConversation]] for details on leaving a conversation.
                * @see [[destroy]] for details on destroying a conversation.
                * @return A Promise that resolves to null or is rejected with a [[UnbluApiError]] if the call fails.
                */
            closeConversation(): Promise<void>;
            /**
                * Returns weather this conversation is destroyed or not.
                *
                * Conversations are either destroyed if [[destroy]] is called or the conversation is closed.
                * This usually happens when the user navigates back to an overview or into an other conversation.
                * @see [[destroy]]
                * @see [[CLOSE]]
                * @return Weather this conversation is destroyed or not.
                */
            isDestroyed(): boolean;
            /**
                * Destroys this conversation API instance.
                *
                * Calling destroy will unregister all event listeners and prohibit any further calls to this object.
                * Once the conversation is destroyed, any subsequent calls will reject the returned promise with [[UnbluErrorCategory.ILLEGAL_STATE]] as reason.
                *
                * **Note that:**
                * - Destroying does NOT close the conversation .
                * - Destroying does NOT end the conversation.
                * - Destroying does NOT leave the conversation.
                * - Other instances of the same Conversation will NOT be destroyed.
                *
                * This call simply destroys this local API instance to the conversation.
                *
                * A destroyed but still open conversation can be accessed again using [[UnbluApi.getActiveConversation]].
                *
                * @see [[isDestroyed]]
                * @see [[closeConversation]] for details on how to close a conversation
                * @see [[endConversation]] for details on how to end a conversation
                */
            destroy(): void;
    }
}

declare module 'unblu/internal/util/event-emitter' {
    export type Listener = (data?: any) => void;
    export class EventEmitter {
            /**
                * Resets the emitter by removing all registered listeners.
                */
            reset(): void;
            /**
                * Adds an event listeners
                * @param event the event to listen to
                * @param listener the listener to be called.
                */
            on(event: string, listener: Listener): void;
            /**
                * removes a previously registered listener
                * @param event the event
                * @param listener the listener that should be removed.
                * @return `true` if the listener was removed, `false` otherwise.
                */
            off(event: string, listener: any): boolean;
            /**
                * removes all listeners for the given event.
                * @param event the event for which all listeners will be removed.
                */
            offAll(event: string): void;
            /**
                * Checks weather at least one listener exists for a given event.
                * @param event the event to check for
                * @return weather or not any listeners for the given event are registered.
                */
            hasListeners(event: string): boolean;
            /**
                * Returns all events that have at least one listeners registered to them.
                * @return An array containing all events that have at least one listener.
                * If no listeners are registered at all, an empty array will be returned.
                */
            getEventsWithListeners(): string[];
            /**
                * Emits an event dispatching it to all listeners registered for it.
                * @param event the event name.
                * @param data the event data.
                */
            emit(event: string, data?: any): void;
    }
}

declare module 'unblu/internal/internal-api' {
    import { ApiBridge } from 'unblu/internal/api-bridge';
    import { MetaModule } from 'unblu/internal/module/meta-module';
    import { GeneralModule } from 'unblu/internal/module/general-module';
    import { GeneralLazyModule } from 'unblu/internal/module/general-lazy-module';
    import { ConversationModule } from 'unblu/internal/module/conversation-module';
    import { AgentAvailabilityModule } from 'unblu/internal/module/agent-availability-module';
    export class InternalApi {
        meta: MetaModule;
        general: GeneralModule;
        generalLazy: GeneralLazyModule;
        conversation: ConversationModule;
        agentAvailability: AgentAvailabilityModule;
        constructor(bridge: ApiBridge);
        checkCompatibility(): void;
    }
}

declare module 'unblu/internal/module/general-module' {
    import { InternalModule } from 'unblu/internal/module/module';
    import { ApiBridge } from 'unblu/internal/api-bridge';
    import { PersonInfo } from 'unblu/model/person-info';
    import { ConversationType } from 'unblu/model/conversation-type';
    export type GeneralEventType = 'activeConversationChange' | 'notificationCountChange' | 'personChange';
    const enum GeneralFunction {
        startConversation = "startConversation",
        joinConversation = "joinConversation",
        openConversation = "openConversation",
        getActiveConversation = "getActiveConversation",
        getNotificationCount = "getNotificationCount",
        getPersonInfo = "getPersonInfo"
    }
    export class GeneralModule extends InternalModule<GeneralFunction, GeneralEventType> {
        constructor(bridge: ApiBridge);
        startConversation(type: ConversationType, visitorName?: string): Promise<string>;
        joinConversation(pin: string, visitorName?: string): Promise<string>;
        openConversation(conversationId: string): Promise<void>;
        getActiveConversation(): Promise<string>;
        getNotificationCount(): Promise<number>;
        getPersonInfo(): Promise<PersonInfo>;
    }
    export {};
}

declare module 'unblu/model/person-info' {
    export interface PersonInfo {
        id: string;
        displayName: string;
    }
}

declare module 'unblu/internal/module/agent-availability-module' {
    import { InternalModule } from 'unblu/internal/module/module';
    import { ApiBridge } from 'unblu/internal/api-bridge';
    import { AgentAvailabilityState } from 'unblu/model/agent-availability-state';
    export type AgentAvailabilityEventType = 'availabilityChange';
    const enum AgentAvailabilityFunction {
        isAgentAvailable = "isAgentAvailable",
        getAgentAvailabilityState = "getAgentAvailabilityState"
    }
    export class AgentAvailabilityModule extends InternalModule<AgentAvailabilityFunction, AgentAvailabilityEventType> {
        constructor(bridge: ApiBridge);
        isAgentAvailable(): Promise<boolean>;
        getAgentAvailabilityState(): Promise<AgentAvailabilityState>;
    }
    export {};
}

declare module 'unblu/internal/module/conversation-module' {
    import { InternalModule } from 'unblu/internal/module/module';
    import { ApiBridge } from 'unblu/internal/api-bridge';
    import { CallState } from 'unblu/model/call-state';
    import { ConversationState } from 'unblu/model/conversation-state';
    import { ConnectionState } from 'unblu/model/connection-state';
    export interface ConversationCallState {
        conversationId: string;
        callState: CallState;
    }
    export interface ConversationConnectionState {
        conversationId: string;
        connectionState: ConnectionState;
    }
    export type ConversationEventType = 'connectionStateChange' | 'end' | 'close' | 'personChange' | 'callStateChange';
    const enum ConversationFunction {
        getConnectionState = "getConnectionState",
        getConversationState = "getConversationState",
        getCallState = "getCallState",
        startAudioCall = "startAudioCall",
        startVideoCall = "startVideoCall",
        endConversation = "endConversation",
        leaveConversation = "leaveConversation",
        closeConversation = "closeConversation"
    }
    export class ConversationModule extends InternalModule<ConversationFunction, ConversationEventType> {
        constructor(bridge: ApiBridge);
        getConnectionState(conversationId: string): Promise<ConnectionState>;
        getConversationState(conversationId: string): Promise<ConversationState>;
        getCallState(conversationId: string): Promise<CallState>;
        startAudioCall(conversationId: string): Promise<void>;
        startVideoCall(conversationId: string): Promise<void>;
        endConversation(conversationId: string): Promise<void>;
        leaveConversation(conversationId: string): Promise<void>;
        closeConversation(conversationId: string): Promise<void>;
    }
    export {};
}

declare module 'unblu/internal/api-bridge' {
    import { EventCallback } from 'unblu/internal/event';
    export class ApiBridge {
            /**
                * instantiates the bridge that links the UNBLU internal API provided by the collaboration server with the UNBLU JS-API
                * @param mountPoint the global unblu object under which the internal API is registered.
                */
            constructor(mountPoint: any);
            waitUntilLoaded(timeout: number, promise?: Promise<void>): Promise<void>;
            checkCompatibility(): void;
            /**
                * Calls an API function of the internal unblu collaboration server API.
                * @param moduleName The module to which the function belongs.
                * @param functionName The function to call.
                * @param args The arguments to pass to the function.
                */
            callApiFunction(moduleName: string, functionName: string, args: any[]): Promise<any>;
            /**
                * Registers a callback for an event emitted by the internal unblu collaboration server API.
                * @param module The module that emits the event.
                * @param event The event name.
                * @param callback The callback which will be called every time the event is emitted.
                */
            on(module: string, event: string, callback: EventCallback): Promise<void>;
            /**
                * Unregisters a callback for an event emitted by the internal unblu collaboration server API.
                * @param module The module that emits the event.
                * @param event The event name.
                * @param callback Optionally callback which will be removed, if none is provided all listeners of the event will be removed.
                */
            off(module: string, event: string, callback?: EventCallback): Promise<void>;
    }
}

declare module 'unblu/internal/module/meta-module' {
    import { InternalModule } from 'unblu/internal/module/module';
    import { ApiBridge } from 'unblu/internal/api-bridge';
    export type MetaEventType = 'upgraded';
    const enum MetaFunction {
        isUpgraded = "isUpgraded",
        upgrade = "upgrade"
    }
    export class MetaModule extends InternalModule<MetaFunction, MetaEventType> {
        constructor(bridge: ApiBridge);
        isUpgraded(): Promise<boolean>;
        upgrade(openUi?: boolean): Promise<boolean>;
    }
    export {};
}

declare module 'unblu/internal/module/general-lazy-module' {
    import { InternalModule } from 'unblu/internal/module/module';
    import { ApiBridge } from 'unblu/internal/api-bridge';
    import { PersonInfo } from 'unblu/model/person-info';
    export type GeneralLazyEventType = '';
    const enum GeneralLazyFunction {
        getNotificationCount = "getNotificationCount",
        getPersonInfo = "getPersonInfo"
    }
    export class GeneralLazyModule extends InternalModule<GeneralLazyFunction, GeneralLazyEventType> {
        constructor(bridge: ApiBridge);
        getNotificationCount(): Promise<number>;
        getPersonInfo(): Promise<PersonInfo>;
    }
    export {};
}

declare module 'unblu/internal/module/module' {
    import { ApiBridge } from 'unblu/internal/api-bridge';
    import { EventCallback } from 'unblu/internal/event';
    export class InternalModule<T extends string, E extends string> {
        moduleName: string;
        constructor(bridge: ApiBridge, moduleName: string);
        protected callApiFunction(functionName: T, args: any[]): Promise<any>;
        on(eventName: E, listener: EventCallback): Promise<void>;
        off(eventName: E, listener: EventCallback): Promise<void>;
    }
}

declare module 'unblu/internal/event' {
    export interface Event<T> {
        module: string;
        name: string;
        data: T;
    }
    export type EventCallback = (event: Event<any>) => void;
}

