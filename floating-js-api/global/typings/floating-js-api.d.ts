// Generated by dts-bundle v0.7.3

declare module 'unblu-floating-js-api' {
    import { AgentAvailabilityChangeListener, AgentAvailableChangeListener, ConversationChangeListener, ConversationsChangeListener, NotificationCountChangeListener, PersonChangeListener, PersonActivityListener, UnbluApi } from 'unblu-floating-js-api/unblu-api';
    import { CallStateListener, ConnectionStateListener, Conversation, ConversationStateListener, InvitationsListener, CustomActionInvocationListener } from 'unblu-floating-js-api/shared/conversation';
    import { NewConversationInterceptor } from "unblu-floating-js-api/shared/new-conversation-interceptor";
    import { NewConversationInterceptorResult } from "unblu-floating-js-api/shared/model/new-conversation-interceptor-result";
    import { ApiState } from "unblu-floating-js-api/shared/api-state";
    import { Configuration, ErrorListener, ReadyListener, UnbluStaticApi } from 'unblu-floating-js-api/unblu-static-api';
    import { CallState } from 'unblu-floating-js-api/shared/model/call-state';
    import { ConnectionState } from 'unblu-floating-js-api/shared/model/connection-state';
    import { ConversationType } from 'unblu-floating-js-api/shared/model/conversation-type';
    import { ConversationRecipient } from "unblu-floating-js-api/shared/model/conversation-recipient";
    import { ConversationRecipientType } from "unblu-floating-js-api/shared/model/conversation-recipient-type";
    import { AgentAvailabilityState } from 'unblu-floating-js-api/shared/model/agent-availability-state';
    import { ConversationState } from 'unblu-floating-js-api/shared/model/conversation-state';
    import { UnbluApiError, UnbluErrorType } from 'unblu-floating-js-api/shared/unblu-api-error';
    import { IndividualUiState } from "unblu-floating-js-api/model/individualui_state";
    import { ActiveIndividualUiView } from "unblu-floating-js-api/model/individualui_component";
    import { InvitationStatus } from "unblu-floating-js-api/shared/model/invitation-status";
    import { UiActiveIndividualUiViewChangeListener, UiStateChangeListener, UnbluUiApi } from "unblu-floating-js-api/unblu-api-ui";
    import { ConversationInfo } from "unblu-floating-js-api/shared/model/conversation-info";
    import { Invitation } from "unblu-floating-js-api/shared/model/invitation";
    import { PersonInfo } from "unblu-floating-js-api/shared/model/person-info";
    import { CustomActionInvocation } from "unblu-floating-js-api/shared/model/customaction/custom-action-invocation";
    export { AgentAvailabilityState };
    export { ApiState, UnbluStaticApi, Configuration, ErrorListener, ReadyListener };
    export { CallState };
    export { ConnectionState };
    export { ConversationState };
    export { ConversationType };
    export { IndividualUiState };
    export { ActiveIndividualUiView };
    export { InvitationStatus };
    export { UnbluErrorType };
    export { Conversation, CallStateListener, ConnectionStateListener, ConversationStateListener, InvitationsListener, CustomActionInvocationListener };
    export { UnbluApi, AgentAvailableChangeListener, AgentAvailabilityChangeListener, ConversationChangeListener, ConversationsChangeListener, NewConversationInterceptor, NewConversationInterceptorResult, ConversationRecipient, ConversationRecipientType, NotificationCountChangeListener, PersonChangeListener, PersonActivityListener };
    export { UnbluApiError };
    export { UnbluUiApi, UiActiveIndividualUiViewChangeListener, UiStateChangeListener };
    export { ConversationInfo };
    export { Invitation };
    export { PersonInfo };
    export { CustomActionInvocation };
    /**
        * The main unblu namespace which gives access to the Unblu API.
        *
        * Access:
        * ```javascript
        * window.unblu.api
        * ```
        *
        * **Note:** all fields inside the unblu namespace except for the {@link api} are not public and may change without any notice.
        */
    export interface Unblu {
            /**
                * Access to the Unblu API.
                *
                * This field will be available as soon as the Unblu API has been loaded.
                */
            api?: UnbluStaticApi;
            AgentAvailabilityState?: typeof AgentAvailabilityState;
            CallState?: typeof CallState;
            ConnectionState?: typeof ConnectionState;
            ConversationState?: typeof ConversationState;
            ConversationType?: typeof ConversationType;
            UnbluErrorType?: typeof UnbluErrorType;
    }
    /**
        * Global window scope definition of the unblu namespace on the window.
        * Access:
        * ```javascript
        * window.unblu.api
        * ```
        * @noInheritDoc
        */
    export interface Globals extends Window {
            /**
                * The main unblu namespace
                */
            unblu: Unblu;
    }
    const _default: {
            /**
                * Access to the Unblu API.
                *
                * This field will be available as soon as the Unblu API has been loaded.
                */
            api: UnbluStaticApi;
            AgentAvailabilityState: typeof AgentAvailabilityState;
            CallState: typeof CallState;
            ConnectionState: typeof ConnectionState;
            ConversationState: typeof ConversationState;
            ConversationType: typeof ConversationType;
            UnbluErrorType: typeof UnbluErrorType;
    };
    export default _default;
}

declare module 'unblu-floating-js-api/unblu-api' {
    import { InternalApi } from 'unblu-floating-js-api/internal/internal-api';
    import { Conversation } from 'unblu-floating-js-api/shared/conversation';
    import { PersonInfo } from 'unblu-floating-js-api/shared/model/person-info';
    import { Listener } from 'unblu-floating-js-api/shared/internal/util/event-emitter';
    import { ConversationType } from 'unblu-floating-js-api/shared/model/conversation-type';
    import { AgentAvailabilityState } from 'unblu-floating-js-api/shared/model/agent-availability-state';
    import { AgentAvailabilityEventType } from 'unblu-floating-js-api/shared/internal/module/agent-availability-module';
    import { UnbluUiApi } from 'unblu-floating-js-api/unblu-api-ui';
    import { MetaEventType } from "unblu-floating-js-api/internal/module/meta-module";
    import { ConversationInfo } from "unblu-floating-js-api/shared/model/conversation-info";
    import { NewConversationInterceptor } from "unblu-floating-js-api/shared/new-conversation-interceptor";
    import { GeneralEventType } from "unblu-floating-js-api/internal/module/general-module";
    import { InitializedUnbluApi } from "unblu-floating-js-api/shared/internal/initialized-unblu-api";
    import { ConversationRecipient } from "unblu-floating-js-api/shared/model/conversation-recipient";
    /**
        * Listener called whenever the active conversation changes.
        *
        * **Note:** If no conversation is currently active the passed conversation object will be `null`
        * @param conversation API object for the active conversation or `null` if no conversation is active.
        */
    export type ConversationChangeListener = (conversation?: Conversation) => void;
    /**
        * Listener called whenever a conversation changed, added or removed from all conversations.
        * @param conversations All conversations of the current visitor.
        */
    export type ConversationsChangeListener = (conversations: ConversationInfo[]) => void;
    /**
        * Listener called whenever the notification count of a person (i.e. unread messages) changes.
        * @param count The number of unseen notifications.
        */
    export type NotificationCountChangeListener = (count: number) => void;
    /**
        * Listener called whenever the local person changes.
        * @param person Info about the person.
        */
    export type PersonChangeListener = (person: PersonInfo) => void;
    /**
        * Listener called whenever there is activity by the person.
        * @param lastActivity A UTC timestamp when the last activity happened.
        */
    export type PersonActivityListener = (lastActivity: Number) => void;
    /**
        * Listener called whenever the agent availability changes.
        * @param isAvailable A boolean that indicates if an agent is available.
        */
    export type AgentAvailableChangeListener = (isAvailable: boolean) => void;
    /**
        * Listener called whenever the agent availability state changes.
        * @param availability The new availability state.
        */
    export type AgentAvailabilityChangeListener = (availability: AgentAvailabilityState) => void;
    /**
        * Listener called whenever the UnbluApi gets de-initialized.
        */
    export type DeinitializationListener = () => void;
    /**
        * #### This class represents the initialized Unblu Visitor JS API.
        *
        * There is only ever one instance of this api which can be retrieved via `unblu.api.initialize()`.
        * See {@link UnbluStaticApi} for more details on configuring and initializing the UnbluApi.
        *
        * The API connects to the integrated version of Unblu. All actions performed via the UnbluApi are executed in
        * the name of and with the rights of current visitor and may have direct effect on the displayed Unblu UI.
        *
        * For example if a conversation is started from the UnbluApi, the Unblu UI will navigate to it.
        * If a conversation is closed via the API, it will also be closed on the Unblu UI of the visitor.
        * For more information on UI side effects please check the documentation for each method call.
        *
        * For programmatic administrator access and configuration of Unblu please use the Unblu WebAPI.
        */
    export class UnbluApi implements InitializedUnbluApi {
            /**
                * Event emitted every time the active conversation changes.
                *
                * This may happen due to a UI-navigation or an API-call.
                *
                * @event activeConversationChange
                * @see {@link on} for listener registration
                * @see {@link ConversationChangeListener}
                */
            static readonly ACTIVE_CONVERSATION_CHANGE: 'activeConversationChange';
            /**
                * Event emitted every time one of the conversations accessible to the current user changes or one is added or removed.
                *
                * @event conversationsChanged
                * @see {@link on} for listener registration
                * @see {@link ConversationsChangeListener}
                */
            static readonly CONVERSATIONS_CHANGE: 'conversationsChange';
            /**
                * Event emitted every time the notification count (unread messages) changes.
                *
                * @event notificationCountChange
                * @see {@link on} for listener registration
                * @see {@link NotificationCountChangeListener}
                */
            static readonly NOTIFICATION_COUNT_CHANGE: 'notificationCountChange';
            /**
                * Event emitted every time the local person changes. This may be i.e. due to the person setting its name.
                *
                * @event personChange
                * @see {@link on} for listener registration
                * @see {@link PersonChangeListener}
                */
            static readonly PERSON_CHANGE: 'personChange';
            /**
                * Event emitted every time the local person has some activity inside Unblu.
                * This may be i.e. an interaction with the chat, a call, opening a conversation or interacting
                * with a co-browsing layer.
                *
                * The event can be used to reset the logout timer inside an authenticated area, for example.
                *
                * The configuration property com.unblu.conversation.activity.activityCategoriesToTrack specifies which categories of activity trigger the event.
                *
                * @event personActivity
                * @see {@link on} for listener registration
                * @see {@link PersonActivityListener}
                */
            static readonly PERSON_ACTIVITY: 'personActivity';
            /**
                * Event emitted every time the agent availability changes for the current named area and locale.
                *
                * @event availableChange
                * @see {@link on} for listener registration
                * @see {@link AgentAvailableChangeListener}
                */
            static readonly AGENT_AVAILABLE_CHANGE: 'availableChange';
            /**
                * Event emitted every time the agent availability state changes for the current named area and locale.
                *
                * @event availabilityChange
                * @see {@link on} for listener registration
                * @see {@link AgentAvailabilityChangeListener}
                */
            static readonly AGENT_AVAILABILITY_CHANGE: 'availabilityChange';
            /**
                * Event emitted when this instance gets de-initialized and is not usable at the time until it fully got de-initialized.
                *
                * @event deinitializing
                * @see {@link on} for listener registration
                * @see {@link DeinitializationListener}
                */
            static readonly DEINITIALIZING: 'deinitializing';
            /**
                * Event emitted when this instance got de-initialized and has to be initialized again.
                *
                * @event deinitialized
                * @see {@link on} for listener registration
                * @see {@link DeinitializationListener}
                */
            static readonly DEINITIALIZED: 'deinitialized';
            /**
                * Access the UI functionality over the UI property.
                */
            ui: UnbluUiApi;
            /**
                * @hidden
                */
            constructor(internalApi: InternalApi);
            /**
                * Registers an event listener for the given event.
                * @param event The activeConversationChange event.
                * @param listener The listener to be called.
                * @see {@link ACTIVE_CONVERSATION_CHANGE}
                */
            on(event: typeof UnbluApi.ACTIVE_CONVERSATION_CHANGE, listener: ConversationChangeListener): void;
            /**
                * Registers an event listener for the given event.
                * @param event The conversationsChanged event.
                * @param listener The listener to be called.
                * @see {@link CONVERSATIONS_CHANGE}
                */
            on(event: typeof UnbluApi.CONVERSATIONS_CHANGE, listener: ConversationsChangeListener): void;
            /**
                * Registers an event listener for the given event.
                * @param event The notificationCountChanged event.
                * @param listener The listener to be called.
                * @see {@link NOTIFICATION_COUNT_CHANGE}
                */
            on(event: typeof UnbluApi.NOTIFICATION_COUNT_CHANGE, listener: NotificationCountChangeListener): void;
            /**
                * Registers an event listener for the given event.
                * @param event The personChange event.
                * @param listener The listener to be called.
                * @see {@link PERSON_CHANGE}
                */
            on(event: typeof UnbluApi.PERSON_CHANGE, listener: PersonChangeListener): void;
            /**
                * Registers an event listener for the given event.
                * @param event The personActivity event.
                * @param listener The listener to be called.
                * @see {@link PERSON_ACTIVITY}
                */
            on(event: typeof UnbluApi.PERSON_ACTIVITY, listener: PersonActivityListener): void;
            /**
                * Registers an event listener for the given event.
                * @param event The agentAvailableChange event.
                * @param listener The listener to be called.
                * @see {@link AGENT_AVAILABLE_CHANGE}
                */
            on(event: typeof UnbluApi.AGENT_AVAILABLE_CHANGE, listener: AgentAvailableChangeListener): void;
            /**
                * Registers an event listener for the given event.
                * @param event The agentAvailabilityChange event.
                * @param listener The listener to be called.
                * @see {@link AGENT_AVAILABILITY_CHANGE}
                */
            on(event: typeof UnbluApi.AGENT_AVAILABILITY_CHANGE, listener: AgentAvailabilityChangeListener): void;
            /**
                * Registers an event listener for the given event.
                * @param event The deinitializing event.
                * @param listener The listener to be called.
                * @see {@link DEINITIALIZING}
                */
            on(event: typeof UnbluApi.DEINITIALIZING, listener: DeinitializationListener): void;
            /**
                * Registers an event listener for the given event.
                * @param event The deinitialized event.
                * @param listener The listener to be called.
                * @see {@link DEINITIALIZED}
                */
            on(event: typeof UnbluApi.DEINITIALIZED, listener: DeinitializationListener): void;
            /**
                * Removes a previously registered listener
                * @param event The event to unregister from.
                * @param listener The listener to remove.
                */
            off(event: GeneralEventType | AgentAvailabilityEventType | MetaEventType, listener: Listener): boolean;
            /**
                * Returns information about the visitor.
                * @return A promise that resolves to the current visitors person info.
                */
            getPersonInfo(): Promise<PersonInfo>;
            /**
                * Sets the current visitor's nickname.
                * This could be set before or during a conversation.
                * @return A promise that resolves empty when the operation is done
                */
            setPersonNickname(nickname: string): Promise<void>;
            /**
                * Logs the current visitor in using the `authenticator/loginWithSecureToken` web API endpoint.
                * Depending on the configuration, existing conversation may will be transferred to the authenticated user.
                * @param accessToken The access token (JWT) to authenticate the visitor with
                * @return A promise that resolves empty if the login succeeds or is rejected if it fails
                */
            login(accessToken: string): Promise<void>;
            /**
                * Checks if the current visitor is authenticated.
                * @return A promise that resolves to a boolean if the visitor is authenticated
                */
            isAuthenticated(): Promise<boolean>;
            /**
                * Logs the visitor out.
                * The user will not have access to conversations from the authenticated visitor he was before anymore. He needs to be authenticated again for that.
                * @return A promise that resolves empty when the logout succeeds or is rejected if it fails
                */
            logout(): Promise<void>;
            /**
                * Returns the number of unread messages.
                * @return A promise that resolves to the current number of unread messages.
                */
            getNotificationCount(): Promise<number>;
            /**
                * Starts a new Conversation and places it into the inbound conversation queue.
                *
                * Starting a new conversation involves an agent availability check.
                * For {@link ConversationType.OFFLINE_CHAT_REQUEST} conversations, the check proceeds as follows:
                * * If an agent is available, the conversation type will be changed to {@link ConversationType.CHAT_REQUEST}.
                * * If no agents are available, it will start an offline conversation provided offline chat requests are enabled in the Unblu server's configuration.
                * * if offline chat requests aren't enabled, the request will be rejected.
                *
                * For all `online` conversation types, the check works as follows:
                * * If an agent is available, the conversation will be started.
                * * If no agents are available, the request will be rejected.
                *
                * You should therefore always check agent availability before starting a new conversation.
                * If no agents are available, only start conversations of the type {@link ConversationType.OFFLINE_CHAT_REQUEST}.
                *
                * **NOTE:** calling this method will NOT automatically open the Unblu UI if it is collapsed. Use [ui.openIndividualUi()]{@link UnbluUiApi.openIndividualUi} if this is needed.
                *
                * @param type The conversation type that shall be started.
                * @param visitorName The name the local visitor should have. This is only taken into account if the visitor is not already authenticated.
                * @param visitorData Custom data for the visitor in any format. **NOTE:** The data which is passed here could be used in [NewConversationCallback]{@link NewConversationInterceptor}
                * @param recipient The team or agent recipient of the conversation. This will overwrite any named area that might be set for this web page. **NOTE:** The data which is passed here could be used in [NewConversationCallback]{@link NewConversationInterceptor}
                * @return A promise that resolves to the conversation object giving API access to the started conversation.
                */
            startConversation(type: ConversationType, visitorName?: string, visitorData?: string, recipient?: ConversationRecipient): Promise<Conversation>;
            /**
                * Set a custom interceptor which will be triggered when a new conversation is started (initiated from UI or JavaScript).
                * @param callback The interceptor which is called before a new conversation is started. The Callback is of type [NewConversationCallback]{@link NewConversationInterceptor}
                * @return A promise that resolves when the interceptor is successfully applied and active.
                */
            setNewConversationInterceptor(callback: NewConversationInterceptor): Promise<void>;
            /**
                * Joins an existing conversation with a given PIN.
                *
                * **NOTE:** calling this method will NOT automatically open the Unblu UI if it is collapsed. Use [ui.openIndividualUi()]{@link UnbluUiApi.openIndividualUi} if this is needed.
                *
                * @param pin The PIN retrieved from the Unblu Agent Desk.
                * @param visitorName The name the local visitor should have. This is only taken into account if the visitor is not already authenticated.
                * @return A promise that resolves to the conversation object giving API access to the joined conversation.
                */
            joinConversation(pin: string, visitorName?: string): Promise<Conversation>;
            /**
                * Opens the existing conversation with the given conversation ID.
                *
                * **NOTE:** calling this method will NOT automatically open the Unblu UI if it is collapsed. Use [ui.openIndividualUi()]{@link UnbluUiApi.openIndividualUi} if this is needed.
                *
                * @param conversationId The id of the conversation to be opened.
                * @return A promise that resolves to the conversation object giving API access to the opened conversation.
                */
            openConversation(conversationId: string): Promise<Conversation>;
            /**
                * Returns the currently active conversation or `null` if no conversation is active.
                *
                * **NOTE:** calling this method twice while the same conversation is active, will result in two individual conversation API instances being returned.
                * destroying one of them will not cause the other one to also be destroyed. If however the active conversation is closed, all returned Conversation instances will be destroyed.
                *
                * @return A promise that either resolves to the currently active conversation or `null` if no conversation is open.
                * @see {@link ACTIVE_CONVERSATION_CHANGE}
                */
            getActiveConversation(): Promise<Conversation | null>;
            /**
                * Returns all conversations of the current visitor. If no conversation is present, an empty array is returned.
                *
                * @return A promise that resolves to an array of [ConversationInfo]{@link ConversationInfo}.
                */
            getConversations(): Promise<ConversationInfo[]>;
            /**
                * Checks if an agent is available for the current named area and language.
                *
                * @return Promise that resolves to `true` if the availability state is [AVAILABLE]{@link AgentAvailabilityState.AVAILABLE} or [BUSY]{@link AgentAvailabilityState.BUSY}, `false` otherwise.
                * @see {@link getAgentAvailabilityState} for a more detailed check.
                */
            isAgentAvailable(): Promise<boolean>;
            /**
                * Returns the current availability state for the current named area and language.
                * @return Promise that resolves to the current availability state.
                * @see {@link isAgentAvailable} for a simpler check.
                */
            getAgentAvailabilityState(): Promise<AgentAvailabilityState>;
            isDeinitialized(): Boolean;
            /**
                * De-initializes the API. It will destroy the UI, all connections and will release all resources (as far as it is technically possible).
                *
                * Afterwards the API can be initialized again via  [window.unblu.api.initialize()]{@link UnbluStaticApi.initialize}
                */
            deinitialize(): Promise<void>;
    }
}

declare module 'unblu-floating-js-api/shared/conversation' {
    import { CallState } from 'unblu-floating-js-api/shared/model/call-state';
    import { ConversationEventType, ConversationModule } from 'unblu-floating-js-api/shared/internal/module/conversation-module';
    import { Listener } from 'unblu-floating-js-api/shared/internal/util/event-emitter';
    import { ConversationState } from 'unblu-floating-js-api/shared/model/conversation-state';
    import { ConnectionState } from 'unblu-floating-js-api/shared/model/connection-state';
    import { Invitation } from "unblu-floating-js-api/shared/model/invitation";
    import { CustomActionInvocation } from 'unblu-floating-js-api/shared/model/customaction/custom-action-invocation';
    export type ConnectionStateListener = (connectionState: ConnectionState) => void;
    export type ConversationStateListener = (conversationState: ConversationState) => void;
    export type CallStateListener = (callState: CallState) => void;
    export type InvitationsListener = (invitations: Invitation[]) => void;
    /**
        * Listener called whenever a custom action invocation triggers an API event for the client
        * @param customActionInvocation The details of the custom action invocation
        */
    export type CustomActionInvocationListener = (customActionInvocation: CustomActionInvocation) => void;
    /**
        * #### This class gives API access to the currently active conversation.
        *
        * As long as a conversation is active one can register and receive the events provided by this class and call the methods.
        * Once the conversation is closed this API object will be destroyed and no more event callbacks will be called.
        * Any subsequent calls will fail.
        *
        * Use the {@link CLOSE} event to de-init any code connected to this conversation.
        */
    export class Conversation {
            /**
                * Event emitted when the {@link ConnectionState} of this conversation changes.
                * @event connectionStateChange
                * @see {@link on} for listener registration
                */
            static readonly CONNECTION_STATE_CHANGE: 'connectionStateChange';
            /**
                * Event emitted when the {@link ConversationState} of this conversation changes.
                * @event conversationStateChange
                * @see {@link on} for listener registration
                */
            static readonly CONVERSATION_STATE_CHANGE: 'conversationStateChange';
            /**
                * Event emitted when the {@link CallState} of this conversation changes.
                * @event callStateChange
                * @see {@link on} for listener registration
                */
            static readonly CALL_STATE_CHANGE: 'callStateChange';
            /**
                * Event emitted when the conversation ends.
                * @deprecated The end event is not always available, depending on the configuration. Use the {@link CONVERSATION_STATE_CHANGE} event instead.
                * @event end
                * @see {@link on} for listener registration
                */
            static readonly END: 'end';
            /**
                * Event emitted when the conversation is closed.
                *
                * This may happen due to a UI-navigation or an API-call.
                *
                * @event close
                * @see {@link on} for listener registration
                */
            static readonly CLOSE: 'close';
            /**
                * Event emitted when an {@link Invitation} is added to or removed from this conversation, or if an existing invitation changes.
                * The event emits an array of all visitor invitations created by the local person, all other invitations will not be present.
                * @event invitationsChange
                * @see {@link on} for listener registration
                */
            static readonly INVITATIONS_CHANGE: 'invitationsChange';
            /**
                * Event emitted every time a custom action is configured to trigger a JS API event for the current client when a custom action is invoked
                *
                * @event customActionInvocation
                * @see {@link CustomActionInvocationListener}
                * @see {@link on} for listener registration
                */
            static readonly CUSTOM_ACTION_INVOCATION: 'customActionInvocation';
            /**
                * @hidden
                */
            constructor(conversationModule: ConversationModule, conversationId: string);
            /**
                * Registers an event listener for the given event.
                * @param event The call state change event.
                * @param listener The listener to be called.
                * @see {@link CONNECTION_STATE_CHANGE}
                */
            on(event: typeof Conversation.CONNECTION_STATE_CHANGE, listener: ConnectionStateListener): void;
            /**
                * Registers an event listener for the given event.
                * @param event The conversation state change event.
                * @param listener The listener to be called.
                * @see {@link CONVERSATION_STATE_CHANGE}
                */
            on(event: typeof Conversation.CONVERSATION_STATE_CHANGE, listener: ConversationStateListener): void;
            /**
                * Registers an event listener for the given event.
                * @param event The call state change event.
                * @param listener The listener to be called.
                * @see {@link CALL_STATE_CHANGE}
                */
            on(event: typeof Conversation.CALL_STATE_CHANGE, listener: CallStateListener): void;
            /**
                * Registers an event listener for the given event.
                * @deprecated The end event is not always available, depending on the configuration. Use instead {@link CONVERSATION_STATE_CHANGE} event.
                * @param event The end event.
                * @param listener The listener to be called.
                * @see {@link END}
                */
            on(event: typeof Conversation.END, listener: () => void): void;
            /**
                * Registers an event listener for the given event.
                * @param event The close event.
                * @param listener The listener to be called.
                * @see {@link CLOSE}
                */
            on(event: typeof Conversation.CLOSE, listener: () => void): void;
            /**
                * Registers an event listener for the given event.
                * @param event The invitations change event.
                * @param listener The listener to be called.
                * @see {@link INVITATIONS_CHANGE}
                */
            on(event: typeof Conversation.INVITATIONS_CHANGE, listener: InvitationsListener): void;
            /**
                * Registers an event listener for the given event.
                * @param event The customActionInvocation event.
                * @param listener The listener to be called.
                * @see {@link CUSTOM_ACTION_INVOCATION}
                */
            on(event: typeof Conversation.CUSTOM_ACTION_INVOCATION, listener: CustomActionInvocationListener): void;
            /**
                * Removes a previously registered listener.
                * @param event The event to unregister from.
                * @param listener The listener to remove.
                */
            off(event: ConversationEventType, listener: Listener): boolean;
            /**
                * Returns the ID of this conversation.
                */
            getConversationId(): string;
            /**
                * Returns the current connection state the conversation is in.
                *
                * If the connection is lost, the conversation will automatically try to reconnect using an exponential back-off strategy.
                * If a fatal error is detected, the state will change to {@link ConnectionState.ERROR}.
                *
                * If this happens, the conversation is in it's terminal state. A dialog or other UI will be displayed to the user with details on the failure.
                * The conversation is not automatically closed in this case.
                * It may either be closed through a manual action by the visitor (confirming the error) or via the API.
                *
                * @see {@link CONNECTION_STATE_CHANGE} if you need to listen to changes.
                * @return A promise that resolves to the current connection state of the conversation
                * or is rejected with a {@link UnbluApiError} if the call fails.
                */
            getConnectionState(): Promise<ConnectionState>;
            /**
                * Returns the current state the conversation is in.
                * @return A promise that resolves to the current state of the conversation
                * or is rejected with a {@link UnbluApiError} if the call fails.
                */
            getConversationState(): Promise<ConversationState>;
            /**
                * @see {@link CALL_STATE_CHANGE} if you need to listen to changes.
                * @return A promise that resolves to the current call state of the local user
                * or is rejected with a {@link UnbluApiError} if the call fails.
                */
            getCallState(): Promise<CallState>;
            /**
                * Creates a new PIN invitation for this conversation.
                *
                * - If the local person doesn't have the right to invite a visitor,
                * the returned promise will be rejected with the unblu error type {@link UnbluErrorType.ACTION_NOT_GRANTED}.
                * @see {@link INVITATIONS_CHANGE} if you need to listen to changes for new invitations on this conversation.
                * @return A promise that resolves to a new {@link Invitation} object with all relevant metadata.
                * or is rejected with a {@link UnbluApiError} if the call fails.
                */
            createAnonymousPinInvitation(): Promise<Invitation>;
            /**
                * Creates a new EMail invitation for this conversation.
                *
                * - If the local person doesn't have the right to invite a visitor,
                * the returned promise will be rejected with the unblu error type {@link UnbluErrorType.ACTION_NOT_GRANTED}.
                * - If a non valid email address is provided,
                * the returned promise will be rejected with the unblu error type {@link UnbluErrorType.INVALID_FUNCTION_ARGUMENTS}.
                * @param email The email which the invitation should be send. It must be a valid email address.
                * @see {@link INVITATIONS_CHANGE} If you need to listen to changes for new invitations on this conversation.
                * @return A promise that resolves to a new {@link Invitation} object with all relevant metadata.
                * or is rejected with a {@link UnbluApiError} if the call fails.
                */
            createAnonymousEmailInvitation(email: String): Promise<Invitation>;
            /**
                * Revoke an invitation.
                *
                * - If the local person doesn't have the right to invite a visitor,
                * the returned promise will be rejected with the unblu error type {@link UnbluErrorType.ACTION_NOT_GRANTED}.
                * @param invitationId The invitation id.
                * @return A Promise that resolves to null or is rejected with a {@link UnbluApiError} if the call fails.
                */
            revokeInvitation(invitationId: String): Promise<void>;
            /**
                * Renews an invitation PIN if the invitation is expired.
                *
                * - If the local person doesn't have the right to invite a visitor,
                * the returned promise will be rejected with the unblu error type {@link UnbluErrorType.ACTION_NOT_GRANTED}.
                * @param invitationId The invitation id.
                * @return A promise that resolves to a new {@link Invitation} object with all relevant metadata.
                */
            renewInvitationPin(invitationId: String): Promise<Invitation>;
            /**
                * Set custom visitor data on the conversation.
                *
                * @param visitorData Custom data for the visitor in any format.
                */
            setVisitorData(visitorData: String): Promise<void>;
            /**
                * Get all visitor invitations created by the local person for this conversation.
                * @return A promise that resolves to a new {@link Invitation} array with all relevant metadata.
                * or is rejected with a {@link UnbluApiError} if the call fails.
                */
            getInvitations(): Promise<Invitation[]>;
            /**
                * Starts a voice call in this conversation.
                *
                * - If a call is already active, this call will be ignored.
                * - If the local person doesn't have the right to start a voice call,
                * the returned promise will be rejected with the unblu error type {@link UnbluErrorType.ACTION_NOT_GRANTED}.
                * @see {@link CALL_STATE_CHANGE} If you need to listen to changes.
                * @return A Promise that resolves to null or is rejected with a {@link UnbluApiError} if the call fails.
                */
            startAudioCall(): Promise<void>;
            /**
                * Starts a video call in this conversation.
                *
                * - If a call is already active, this call will be ignored.
                * - If the local person doesn't have the right to start a video call,
                * the returned promise will be rejected with the unblu error type {@link UnbluErrorType.ACTION_NOT_GRANTED}.
                * @see {@link CALL_STATE_CHANGE} If you need to listen to changes.
                * @return A Promise that resolves to null or is rejected with a {@link UnbluApiError} if the call fails.
                */
            startVideoCall(): Promise<void>;
            /**
                * Ends and closes this conversation.
                *
                * If the local person doesn't have the right to end the conversation,
                * the returned promise will be rejected with the unblu error type {@link UnbluErrorType.ACTION_NOT_GRANTED}.
                * @see {@link END} fired after this call.
                * @see {@link closeConversation} for details on closing a conversation.
                * @return A Promise that resolves to null or is rejected with a {@link UnbluApiError} if the call fails.
                */
            endConversation(): Promise<void>;
            /**
                * Leaves and closes this conversation.
                *
                * By leaving, the visitor is removed from the active participant list of the conversation.
                * Once a conversation is left, the visitor can not re-open it. It will not be visible in the conversation history either.
                *
                * If the local person doesn't have the right to leave the conversation,
                * the returned promise will be rejected with the unblu error type {@link UnbluErrorType.ACTION_NOT_GRANTED}.
                * @see {@link CLOSE} fired after this call.
                * @see {@link closeConversation} for details on closing a conversation without leaving.
                * @return A Promise that resolves to null or is rejected with a {@link UnbluApiError} if the call fails.
                */
            leaveConversation(): Promise<void>;
            /**
                * Closes this conversation locally.
                *
                * When called, the connection to this conversation is closed and the overview is displayed.
                *
                * **Note that:**
                * - Closing does NOT end the conversation.
                * - The person does NOT leave the conversation.
                * - All Conversation api instances for this conversation will be destroyed.
                *
                * The conversation can be joined again either via the UI or using {@link UnbluApi.openConversation}.
                * @see {@link CLOSE} fired after this call.
                * @see {@link endConversation} for details on ending a conversation.
                * @see {@link leavingConversation} for details on leaving a conversation.
                * @see {@link destroy} for details on destroying a conversation.
                * @return A Promise that resolves to null or is rejected with a {@link UnbluApiError} if the call fails.
                */
            closeConversation(): Promise<void>;
            /**
                * Returns weather this conversation is destroyed or not.
                *
                * Conversations are destroyed if {@link destroy} is called or the conversation is closed.
                * This usually happens when the user navigates back to an overview or into an other conversation.
                * @see {@link destroy}
                * @see {@link CLOSE}
                * @return Weather this conversation is destroyed or not.
                */
            isDestroyed(): boolean;
            /**
                * Destroys this conversation API instance.
                *
                * Calling destroy will unregister all event listeners and prohibit any further calls to this object.
                * Once the conversation is destroyed, any subsequent calls will reject the returned promise with {@link UnbluErrorType.ILLEGAL_STATE} as the reason.
                *
                * **Note that:**
                * - Destroying does NOT close the conversation .
                * - Destroying does NOT end the conversation.
                * - Destroying does NOT leave the conversation.
                * - Other instances of the same Conversation will NOT be destroyed.
                *
                * This call simply destroys this local API instance to the conversation.
                *
                * A destroyed but still open conversation can be accessed again using {@link UnbluApi.getActiveConversation}.
                *
                * @see {@link isDestroyed}
                * @see {@link closeConversation} for details on how to close a conversation
                * @see {@link endConversation} for details on how to end a conversation
                */
            destroy(): void;
    }
}

declare module 'unblu-floating-js-api/shared/new-conversation-interceptor' {
    import { ConversationType } from "unblu-floating-js-api/shared/model/conversation-type";
    import { ConversationRecipient } from "unblu-floating-js-api/shared/model/conversation-recipient";
    import { NewConversationInterceptorResult } from "unblu-floating-js-api/shared/model/new-conversation-interceptor-result";
    /**
      * Interceptor function which is called every time a new conversation is started from the UI or JS API.
      *
      * Starting the conversation is deferred until the Promise returned by this interceptor resolves:
      * - If the interceptor rejects the Promise, starting the conversation will be cancelled.
      * - If the interceptor resolves the Promise with a String, the value of the String will be used and set as "visitorData" for the conversation created.
      * - If the interceptor resolves the Promise with a {@link NewConversationInterceptorResult}, the values from it will be used for the "visitorData" and the "recipient" for the conversation created.
      * - If the resolved value is undefined, the value passed into the [startConversation]{@link startConversation} method will be used.
      * - If the resolved value is set to null, any value passed into [startConversation]{@link startConversation} will be discarded.
      * - If the resolved value is neither a {@link NewConversationInterceptorResult}, nor a String, nor undefined, the conversation is started without any visitorData.
      * - If the interceptor resolves the Promise with something other than a {@link NewConversationInterceptorResult} or a String, the conversation is started without any visitorData.
      *
      * Any values of {@link NewConversationInterceptorResult} that are undefined are replaced by the corresponding values passed to [startConversation]{@link startConversation}.
      * Any values of {@link NewConversationInterceptorResult} that are null discard the corresponding values passed to [startConversation]{@link startConversation}.
      *
      * @param conversationType The type of the conversation being started.
      * @param visitorData Optional visitorData, only present if passed to the [startConversation]{@link startConversation} method
      * @param recipient Optional recipient, only present if passed to the [startConversation]{@link startConversation} method
      * @return A Promise deferring the start of the conversation until it resolves.
      */
    export type NewConversationInterceptor = (conversationType: ConversationType, visitorData?: String, recipient?: ConversationRecipient) => Promise<String | NewConversationInterceptorResult>;
}

declare module 'unblu-floating-js-api/shared/model/new-conversation-interceptor-result' {
    import { ConversationRecipient } from "unblu-floating-js-api/shared/model/conversation-recipient";
    /**
        * The result of calling a {@link NewConversationInterceptor}.
        */
    export interface NewConversationInterceptorResult {
            /**
                * Custom visitor data that will be stored on the conversation and can be accessed through the Web API later on. This data won't be displayed anywhere and is for API usage only.
                */
            visitorData?: string;
            /**
                * The team or agent recipient of the conversation. This overwrites any named area that may be set on the web page.
                */
            recipient?: ConversationRecipient;
    }
}

declare module 'unblu-floating-js-api/shared/api-state' {
    export enum ApiState {
        INITIAL = "INITIAL",
        INITIALIZING = "INITIALIZING",
        INITIALIZED = "INITIALIZED",
        ERROR = "ERROR",
        DEINITIALIZING = "DEINITIALIZING",
        DEINITIALIZED = "DEINITIALIZED"
    }
}

declare module 'unblu-floating-js-api/unblu-static-api' {
    import { UnbluApi } from 'unblu-floating-js-api/unblu-api';
    import { Listener } from 'unblu-floating-js-api/shared/internal/util/event-emitter';
    import { ApiState } from "unblu-floating-js-api/shared/api-state";
    import { Configuration } from "unblu-floating-js-api/shared/model/configuration";
    import { UnbluApiFactory } from "unblu-floating-js-api/shared/internal/unblu-api-factory";
    export { Configuration };
    export type ReadyListener = (api: UnbluApi) => void;
    export type ErrorListener = (e: Error) => void;
    export type DeinitializingListener = () => void;
    export type DeinitializedListener = () => void;
    export type StateListener = (state: ApiState) => void;
    /**
        * #### The central entry point that allows to configure an initialize the Unblu Visitor JS API.
        * The static Unblu API works without actually loading the rest of Unblu.
        * It can do some general checks and load Unblu or connect the API to a loaded version of Unblu.
        * The JS API is an optional add-on to the Unblu visitor site integration.
        *
        * Depending on how Unblu is integrated into the local website the API has to be initialized differently.
        *
        * **a.) API-only integration**
        * If no unblu-snippet is loaded into the page, Unblu can be fully initialized with the API.
        * In this case, both the `configure` and the `initialize` methods have to be called.
        * Example:
        * ```ts
        *  const api = await unblu.api
        *      // configure the unblu server
        *      .configure({
        *          apiKey: "<your-api-key>",
        *          serverUrl: "<unblu-server-url>"
        *      })
        *      // initialize the api.
        *      .initialize();
        * ```
        * This implementation will load the Unblu snippet and initialize both Unblu and the JS API.
        *
        * **b.) Snippet and JS API integration**
        * If the Unblu snippet is already present in the local website, Unblu doesn't have to be loaded
        * and only the API has to be initialized.
        * Example:
        * ```ts
        * // directly initialize the api without configuring.
        * const api = await unblu.api.initialize();
        *
        * ```
        */
    export class UnbluStaticApi implements UnbluApiFactory {
            /**
                * Event emitted as soon as the API is initialized.
                *
                * It usually makes sense to use this event if there is some general action that has to be triggered when the API is initialized,
                * but there are several places in the integration code that may trigger the initialization.
                *
                * In most cases however, it is better to use
                * ```ts
                * unblu.api.initialize().then(api => { //use api here });
                * ```
                * or
                * ```ts
                * let api = await unblu.api.initialize();
                * // use api here
                * ```
                *
                * Note: that this event will be triggered again after each initialization.
                *
                * @event ready
                * @see {@link on} for listener registration
                */
            static readonly READY: 'ready';
            /**
                * Event emitted if the API initialization fails.
                *
                * It usually makes sense to use this event if there is some general action that has to be triggered when the API initialization fails,
                * but there are several places in the integration code that may trigger the initialization.
                *
                * In most cases however, it is better to use
                * ```ts
                * unblu.api.initialize().catch(error=> { //handle error here });
                * ```
                * or
                * ```ts
                * try{
                *      let api = await unblu.api.initialize();
                * }catch(e){
                *     // handle error here
                * }
                *
                * ```
                *
                * @event error
                * @see {@link on} for listener registration
                */
            static readonly ERROR: 'error';
            /**
                * Event emitted as soon as the API is going to get de-initialized.
                *
                * It usually makes sense to use this event to clean up resources and/or unregistering of listeners to no try to use the API again until it is initialized again.
                *
                * @event deinitializing
                * @see {@link on} for listener registration
                */
            static readonly DEINITIALIZING: 'deinitializing';
            /**
                * Event emitted as soon as the API is completely de-initialized.
                *
                * It usually makes sense to use this event to clean up resources and/or unregistering of listeners to no try to use the API again until it is initialized again.
                *
                * @event deinitialized
                * @see {@link on} for listener registration
                */
            static readonly DEINITIALIZED: 'deinitialized';
            /**
                * Event emitted whenever the API state changes
                *
                * @event state
                * @see {@link on} for listener registration
                */
            static readonly STATE: 'state';
            /**
                * @hidden
                */
            constructor();
            /**
                * Registers an event listener for the given event.
                *
                * **Note** If the API is already initialized, this listener will be called directly.
                * @param event The ready event
                * @param listener The listener to be called.
                * @see {@link READY}
                */
            on(event: typeof UnbluStaticApi.READY, listener: ReadyListener): void;
            /**
                * Registers an event listener for the given event.
                *
                * **Note** If the API has already failed, this listener will be called directly.
                * @param event The error event
                * @param listener The listener to be called.
                * @see {@link ERROR}
                */
            on(event: typeof UnbluStaticApi.ERROR, listener: ErrorListener): void;
            /**
                * Registers an event listener for the given event.
                *
                * **Note** If the API is already deinitializing, this listener will be called directly.
                * @param event The deinitializing event
                * @param listener The listener to be called.
                * @see {@link DEINITIALIZING}
                */
            on(event: typeof UnbluStaticApi.DEINITIALIZING, listener: DeinitializingListener): void;
            /**
                * Registers an event listener for the given event.
                *
                * **Note** If the API is already deinitialized, this listener will be called directly.
                * @param event The deinitialized event
                * @param listener The listener to be called.
                * @see {@link DEINITIALIZED}
                */
            on(event: typeof UnbluStaticApi.DEINITIALIZED, listener: DeinitializedListener): void;
            /**
                * Registers an event listener for the given event.
                *
                * @param event The state event
                * @param listener The listener to be called.
                * @see {@link STATE}
                */
            on(event: typeof UnbluStaticApi.STATE, listener: StateListener): void;
            /**
                * Removes a previously registered listener.
                * @param event The event unregister.
                * @param listener The listener to be removed.
                * @return `true` if the listener was removed, `false` otherwise.
                */
            off(event: string, listener: Listener): boolean;
            /**
                * Checks whether the API has to be configured or not.
                *
                * - If no snippet is present and the API state is still [INITIAL]{@link ApiState.INITIAL} a configuration is necessary.
                * - If a snippet is present or the API is already loaded, configuration is not necessary.
                * - If the API state is in [DEINITIALIZED]{@link ApiState.DEINITIALIZED}
                *
                * @return `true` if a configuration is needed to initialize the API, `false` otherwise.
                * @see {@link configure} to configure the API
                * @see {@link initialize} to initialize the API
                */
            isConfigurationNeeded(): boolean;
            /**
                * Returns the current state of the API
                * @return the current API state.
                * @see {@link isInitialized} for a simpler check
                */
            getApiState(): ApiState;
            /**
                * Checks whether the API is initialized or not.
                * @return `true` if the API is initialized, `false` for any other state.
                * @see {@link getApiState} for the full state
                */
            isInitialized(): boolean;
            /**
                * Configures the way that Unblu should be initialized.
                *
                * The configuration of the Unblu API is needed when, and only when no Unblu snippet is already present in the website.
                *
                * **Note:**
                * - Calling this method when there's already an Unblu snippet will result in an {@link UnbluApiError}.
                * - This method must be called BEFORE {@link initialize}.
                * If it is called afterwards an {@link UnbluApiError} will be thrown.
                *
                * @param config The configuration to be set.
                * @return an instance of `this` allowing chaining like `unblu.api.configure({...}).initialize();`
                * @see {@link isConfigurationNeeded} to check if configuration is needed or not.
                */
            configure(config: Configuration): UnbluStaticApi;
            /**
                * Initializes the API and resolves to the fully initialized API.
                *
                * If the API has already been initialized or is already in the initializing process, the existing API will be returned.
                * There is only ever one instance of the API which will be returned by any call of this method which makes it safe to call this multiple times.
                *
                * *The initialization may fail with a {@link UnbluApiError} for the following reasons*
                * - A configuration is needed but none was provided: [CONFIGURATION_MISSING]{@link UnbluErrorType.CONFIGURATION_MISSING}
                * - Loading Unblu encounters a problem: [ERROR_LOADING_UNBLU]{@link UnbluErrorType.ERROR_LOADING_UNBLU}
                * - The initialization timed out: [INITIALIZATION_TIMEOUT]{@link UnbluErrorType.INITIALIZATION_TIMEOUT}
                * - The Unblu API is incompatible with the Unblu server: [INCOMPATIBLE_UNBLU_VERSION]{@link UnbluErrorType.INCOMPATIBLE_UNBLU_VERSION}
                * - The browser is unsupported: [UNSUPPORTED_BROWSER]{@link UnbluErrorType.UNSUPPORTED_BROWSER}
                * - The provided access token is invalid: [AUTHENTICATION_FAILED]{@link UnbluErrorType.AUTHENTICATION_FAILED}
                */
            initialize(): Promise<UnbluApi>;
    }
}

declare module 'unblu-floating-js-api/shared/model/call-state' {
    export enum CallState {
            /**
                * A some one is trying to call, the phone is ringing
                */
            INBOUND = "INBOUND",
            /**
                * You are trying to call someone
                */
            OUTBOUND = "OUTBOUND",
            /**
                * A call is active and the local tab is connected to the call.
                */
            ACTIVE_JOINED = "ACTIVE_JOINED",
            /**
                * A call is active but the local person has declined it.
                */
            ACTIVE_NOT_JOINED = "ACTIVE_NOT_JOINED",
            /**
                * A call is active and the local person has joined it on an other device.
                */
            ACTIVE_JOINED_ELSEWHERE = "ACTIVE_JOINED_ELSEWHERE",
            /**
                * No inbound, outgoing or active call.
                */
            NONE = "NONE"
    }
}

declare module 'unblu-floating-js-api/shared/model/connection-state' {
    export enum ConnectionState {
            /**
                * Initial state before connection establishment has started
                */
            INITIAL = "INITIAL",
            /**
                * State during the first connection to the server
                */
            CONNECTING = "CONNECTING",
            /**
                * The connection has been successfully established.
                */
            CONNECTED = "CONNECTED",
            /**
                * The connection has been lost, reconnect is active.
                */
            RECONNECTING = "RECONNECTING",
            /**
                * The connection has been successfully closed.
                *
                */
            CLOSED = "CLOSED",
            /**
                * A fatal error has occurred. The connection has been permanently lost. No reconnect will be be possible.
                */
            ERROR = "ERROR"
    }
}

declare module 'unblu-floating-js-api/shared/model/conversation-type' {
    export enum ConversationType {
            /**
                * (Visitor initiated, visitor centered) A visitor creates an incoming chat conversation.
                */
            CHAT_REQUEST = "CHAT_REQUEST",
            /**
                * (Visitor initiated, visitor centered) A visitor creates an incoming chat conversation while all agents are offline.
                */
            OFFLINE_CHAT_REQUEST = "OFFLINE_CHAT_REQUEST",
            /**
                * (Visitor initiated, visitor centered) A visitor creates an incoming video conversation.
                */
            VIDEO_REQUEST = "VIDEO_REQUEST",
            /**
                * (Visitor initiated, visitor centered) A visitor creates an incoming audio conversation.
                */
            AUDIO_REQUEST = "AUDIO_REQUEST",
            /**
                * (Visitor initiated, visitor centered) A visitor creates an incoming universal co-browsing conversation.
                */
            HEADLESS_BROWSER_REQUEST = "HEADLESS_BROWSER_REQUEST",
            /**
                * (Visitor initiated, visitor centered) A visitor creates an incoming embedded co-browsing conversation.
                */
            DOMCAP_BROWSER_REQUEST = "DOMCAP_BROWSER_REQUEST",
            /**
                * (Visitor initiated, visitor centered) A visitor creates an incoming mobile co-browsing conversation.
                */
            MOBILE_COBROWSING_REQUEST = "MOBILE_COBROWSING_REQUEST",
            /**
                * (Visitor initiated, visitor centered) A visitor creates an incoming whiteboard conversation.
                */
            WHITEBOARD_REQUEST = "WHITEBOARD_REQUEST",
            /**
                * (Visitor initiated, visitor centered) A visitor creates an incoming screen sharing conversation.
                */
            SCREEN_SHARING_REQUEST = "SCREEN_SHARING_REQUEST",
            /**
                * (Api initiated, visitor centered) A visitor creates a conversation via API which is not added to the queue and where he can invite other visitor to do
                * embedded
                */
            VISITOR_COBROWSING = "VISITOR_COBROWSING"
    }
}

declare module 'unblu-floating-js-api/shared/model/conversation-recipient' {
    import { ConversationRecipientType } from "unblu-floating-js-api/shared/model/conversation-recipient-type";
    /**
        * The recipient of a conversation
        */
    export interface ConversationRecipient {
            /**
                * The ID of the recipient. Depending on the type, this either refers to an agent person ID or to a team ID
                */
            id: string;
            /**
                * The type of the recipient
                */
            type: ConversationRecipientType;
    }
}

declare module 'unblu-floating-js-api/shared/model/conversation-recipient-type' {
    export enum ConversationRecipientType {
            /**
                * The recipient type for a conversation is an agent
                */
            AGENT = "AGENT",
            /**
                * The recipient type for a conversation is a team
                */
            TEAM = "TEAM"
    }
}

declare module 'unblu-floating-js-api/shared/model/agent-availability-state' {
    export enum AgentAvailabilityState {
            /**
                * There is at least one agent available for the specified named area and locale.
                */
            AVAILABLE = "AVAILABLE",
            /**
                * There is at least one agent watching the inbound queue for the specified named area and locale but the max capacity of parallel conversations is reached.
                *
                * It is very likely, that an agent will be available in a short time.
                */
            BUSY = "BUSY",
            /**
                * There is currently no agent handling any inbound queue items.
                *
                * It is very unlikely, that an agent will be available in a short time.
                */
            UNAVAILABLE = "UNAVAILABLE"
    }
}

declare module 'unblu-floating-js-api/shared/model/conversation-state' {
    export enum ConversationState {
            /**
                * Initial state of a conversation
                */
            CREATED = "CREATED",
            /**
                * Depending of the engagement type of the conversation, the conversation stays in the onboarding state as long as the person in the center of the conversation
                * is doing his onboarding
                */
            ONBOARDING = "ONBOARDING",
            /**
                * When a message is send to an unassigned conversation, the conversation first is put into the reboarding state as long as the person in the center of the
                * conversation is doing the reboarding.
                */
            REBOARDING = "REBOARDING",
            /**
                * Depending of the engagement type of the conversation, the conversation is put in the queued state when it is inside the queue.
                */
            QUEUED = "QUEUED",
            /**
                * Conversation is active
                */
            ACTIVE = "ACTIVE",
            /**
                * After there is no assignee of a conversation anymore, the conversation goes to unassigned state until a message from a visitor is written to start reboarding
                * again.
                */
            UNASSIGNED = "UNASSIGNED",
            /**
                * Conversation is being ended
                */
            OFFBOARDING = "OFFBOARDING",
            /**
                * Conversation is ended
                */
            ENDED = "ENDED"
    }
}

declare module 'unblu-floating-js-api/shared/unblu-api-error' {
    /**
        * Type of an unblu error. This can be used to check what kind of error occurred.
        */
    export enum UnbluErrorType {
            /**
                * Thrown if the browser is not supported by unblu.
                */
            UNSUPPORTED_BROWSER = "UNSUPPORTED_BROWSER",
            /**
                * Thrown if the initialization of the unblu API failed due to a timeout.
                */
            INITIALIZATION_TIMEOUT = "INITIALIZATION_TIMEOUT",
            /**
                * Thrown if the initialization is called with no existing snippet and no configuration.
                */
            CONFIGURATION_MISSING = "CONFIGURATION_MISSING",
            /**
                * Thrown if the login against the Unblu collaboration server failed.
                */
            AUTHENTICATION_FAILED = "AUTHENTICATION_FAILED",
            /**
                * Thrown during initialization if the snippet can't be loaded or unblu can't be initialized from the snippet.
                */
            ERROR_LOADING_UNBLU = "ERROR_LOADING_UNBLU",
            /**
                * Thrown if the unblu JS API is not compatible with the unblu collaboration server.
                */
            INCOMPATIBLE_UNBLU_VERSION = "INCOMPATIBLE_UNBLU_VERSION",
            /**
                * Thrown if a function call was invalid.
                * This is usually do to an incompatibility between the unblu JS API and the unblu collaboration server.
                */
            INVALID_FUNCTION_CALL = "INVALID_FUNCTION_CALL",
            /**
                * Thrown if the arguments passed to a function where invalid.
                */
            INVALID_FUNCTION_ARGUMENTS = "INVALID_FUNCTION_ARGUMENTS",
            /**
                * Thrown if a called action is not permitted for the local person.
                * The details message usually has more information about the required permissions.
                */
            ACTION_NOT_GRANTED = "ACTION_NOT_GRANTED",
            /**
                * Thrown if an unexpected exception occurrs during a function execution.
                */
            EXECUTION_EXCEPTION = "EXECUTION_EXCEPTION",
            /**
                * Thrown if a method is called in an invalid context. E.g. if the Object called upon was already destroyed.
                */
            ILLEGAL_STATE = "ILLEGAL_STATE",
            /**
             * Thrown if a timeout ocurrs.
             */
            TIMEOUT = "TIMEOUT"
    }
    /**
        * General unblu JS API error class that will be thrown whenever something goes wrong.
        *
        * - Use the {@link UnbluApiError.type} to check what kind of error occurred.
        * - Use the {@link UnbluApiError.detail} for human readable details.
        *
        * Check the documentation of {@link UnbluErrorType} for more details on the different error types.
        *
        * Example:
        * ```ts
        * unblu.api.initialize().then(api => {
        *      // use the api
        * }).catch(e => {
        *     if(e.type === 'INITIALIZATION_TIMEOUT') {
        *          //retry
        *     } else if(e.type === 'UNSUPPORTED_BROWSER') {
        *          // display unsupported browser dialog
        *     } else {
        *          // show generic error message
        *     }
        * })
        * ```
        *
        * or using async / await:
        *
        * ```ts
        * try {
        *     const api = await unblu.api.initialize()
        *     // use the api
        * } catch(e) {
        *     if(e.type === 'INITIALIZATION_TIMEOUT') {
        *          //retry
        *     } else if(e.type === 'UNSUPPORTED_BROWSER') {
        *          // display unsupported browser dialog
        *     } else {
        *          // show generic error message
        *     }
        * }
        * ```
        *
        *
        * The error types may either be checked via their constant string values or via the UnbluErrorType enum:
        *
        * ```ts
        * // using string constant
        * function isTimeout(e: UnbluApiError) {
        *  return e.type === 'INITIALIZATION_TIMEOUT'
        * }
        * ```
        * ```ts
        * // using the enum
        * function isTimeout(e: UnbluApiError) {
        *  return e.type === window.unblu.UnbluErrorType.INITIALIZATION_TIMEOUT
        * }
        * ```
        *
        */
    export class UnbluApiError extends Error {
            type: UnbluErrorType;
            detail: string;
            constructor(type: UnbluErrorType, detail: string);
    }
}

declare module 'unblu-floating-js-api/model/individualui_state' {
    export const enum IndividualUiState {
            /**
                * The individual ui is open.
                */
            OPEN = "OPEN",
            /**
                * The individual ui is collapsed.
                */
            COLLAPSED = "COLLAPSED",
            /**
                * The individual ui is popped out.
                */
            POPPED_OUT = "POPPED_OUT"
    }
}

declare module 'unblu-floating-js-api/model/individualui_component' {
    export const enum ActiveIndividualUiView {
            /**
                * The individual UI is showing the overview.
                */
            OVERVIEW = "OVERVIEW",
            /**
                * The individual UI is showing the pin entry screen.
                */
            PIN_ENTRY = "PIN_ENTRY",
            /**
                * The individual UI is showing messages in a conversation.
                */
            CONVERSATION_MESSAGING = "CONVERSATION_MESSAGING",
            /**
                * The individual UI is showing the shared media view.
                */
            CONVERSATION_SHARED_MEDIA = "CONVERSATION_SHARED_MEDIA",
            /**
                * The individual UI is showing messages in a conversation.
                */
            CONVERSATION_CALL = "CONVERSATION_CALL",
            /**
                * The Floating Visitor UI hasn't fully initialized or active view is unknown.
                *
                * NOTE: You shouldn't rely on this option for specific views. New views added to the Unblu individual UI will show
                * as {@link UNKNOWN} at first but may be added to the enum as a specific view at some point in the future.
                */
            UNKNOWN = "UNKNOWN"
    }
}

declare module 'unblu-floating-js-api/shared/model/invitation-status' {
    export enum InvitationStatus {
            /**
                * Invitation is open however it may have expired.
                */
            OPEN = "OPEN",
            /**
                * Invitation is redeemed.
                */
            REDEEMED = "REDEEMED",
            /**
                * Invitation is revoked.
                */
            REVOKED = "REVOKED"
    }
}

declare module 'unblu-floating-js-api/unblu-api-ui' {
    import { InternalApi } from 'unblu-floating-js-api/internal/internal-api';
    import { Listener } from 'unblu-floating-js-api/shared/internal/util/event-emitter';
    import { IndividualUiState } from 'unblu-floating-js-api/model/individualui_state';
    import { GeneralEventType } from "unblu-floating-js-api/internal/module/general-module";
    import { ActiveIndividualUiView } from "unblu-floating-js-api/model/individualui_component";
    /**
        * Listener called whenever the UI state changes.
        * @param uistate The new UI state.
        */
    export type UiStateChangeListener = (uistate: IndividualUiState) => void;
    /**
        * Listener called whenever the active individual UI view changes.
        *
        * NOTE: This listener is also triggered when the view in individual UI changes, but the UI isn't
        * visible, for example, because it's collapsed.
        *
        * @param uicomponent The new individual UI component.
        */
    export type UiActiveIndividualUiViewChangeListener = (uicomponent: ActiveIndividualUiView) => void;
    /**
        * This class allows you to control the UI state and the Unblu individual UI.
        */
    export class UnbluUiApi {
            /**
                * Event emitted every time the state of the individual UI is changed.
                *
                * @event uiStateChange
                * @see {@link on} for listener registration
                * @see {@link UiStateChangeListener}
                */
            static readonly UI_STATE_CHANGE: 'uiStateChange';
            /**
                * Event emitted every time individual UI view changes.
                *
                * NOTE: This event is also triggered when an individual UI view change happens, but the UI isn't
                * visible, for example, because it's collapsed.
                *
                * @event uiActiveIndividualUiViewChange
                * @see {@link on} for listener registration
                * @see {@link UiActiveIndividualUiViewChangeListener}
                */
            static readonly UI_ACTIVE_INDIVIDUAL_UI_VIEW_CHANGE: 'uiActiveIndividualUiViewChange';
            /**
                * @hidden
                */
            constructor(internalApi: InternalApi);
            /**
                * Registers an event listener for the given event.
                * @param event The uistateChange event.
                * @param listener The listener to be called.
                * @see {@link UI_STATE_CHANGE}
                */
            on(event: typeof UnbluUiApi.UI_STATE_CHANGE, listener: UiStateChangeListener): void;
            /**
                * Registers an event listener for the given event.
                * @param event The uiOverviewOpen event.
                * @param listener The listener to be called.
                * @see {@link UI_ACTIVE_INDIVIDUAL_UI_VIEW_CHANGE}
                */
            on(event: typeof UnbluUiApi.UI_ACTIVE_INDIVIDUAL_UI_VIEW_CHANGE, listener: UiActiveIndividualUiViewChangeListener): void;
            /**
                * Removes a previously registered listener
                * @param event The event to unregister from.
                * @param listener The listener to remove.
                */
            off(event: GeneralEventType, listener: Listener): boolean;
            /**
                * Opens the individual UI if it is collapsed and collapses it if it is open.
                */
            toggleIndividualUi(): Promise<void>;
            /**
                * Navigates the individual UI to the PIN entry UI.
                *
                * **NOTE:** calling this method will NOT automatically open the Unblu UI if it is collapsed. Use {@link openIndividualUi} if this is needed.
                */
            openPinEntryUi(): Promise<void>;
            /**
                * Navigates the individual UI to the overview UI.
                *
                * <p>
                *     Be aware that this method will force to close any currently open conversation. Depending on the conversation's configuration and the activity in it a prompt may be displayed that has to be accepted by the visitor before the navigation to the overview can happen.
                * </p>
                *
                * **NOTE:** calling this method will NOT automatically open the Unblu UI if it is collapsed. Use {@link openIndividualUi} if this is needed.
                */
            openOverviewUi(): Promise<void>;
            /**
                * Pop-out the individual UI into a separate window.
                *
                * **NOTE:** this has to be called in a click-event in order to be able to open the pop-up window without being blocked by the browser!
                */
            popoutIndividualUi(): Promise<void>;
            /**
                * Pop-in the individual UI when it is in [POPPED_OUT]{@link IndividualUiState.POPPED_OUT} state.
                *
                * The pop-out window will automatically close and the individual UI will be displayed in the original window again.
                */
            popinIndividualUi(): Promise<void>;
            /**
                * Maximize the individual UI - Does nothing if it is already maximized or popped out.
                */
            maximizeIndividualUi(): Promise<void>;
            /**
                * Minimize the individual UI - Does nothing if it is already minimized.
                */
            minimizeIndividualUi(): Promise<void>;
            /**
                * Opens the individual UI if it was collapsed. - Does nothing if it was already open.
                */
            openIndividualUi(): Promise<void>;
            /**
                * Collapses the individual UI if it was open. - Does nothing if it was already collapsed.
                */
            collapseIndividualUi(): Promise<void>;
            /**
                * Get the state of the individual UI.
                * @return A promise that resolves to the {@link IndividualUiState} of the individual UI.
                */
            getIndividualUiState(): Promise<IndividualUiState>;
            /**
                * Get the active individual UI view.
                *
                * NOTE: The view being active doesn't necessarily mean it's visible to the user. The UI as a whole may be
                * collapsed, for instance.
                *
                * @return A promise that resolves to the {@link ActiveIndividualUiView} of the individual UI.
                * @see {@link getIndividualUiState}
                */
            getActiveIndividualUiView(): Promise<ActiveIndividualUiView>;
    }
}

declare module 'unblu-floating-js-api/shared/model/conversation-info' {
    export interface ConversationInfo {
            /**
                * The Id of the conversation.
                */
            id: string;
            /**
                * The Id of the assignee person (typically an agent). May be null if no agent is part of the conversation yet.
                */
            assigneeId?: string;
            /**
                * The Id of the context person (typically the visitor).
                */
            contextPersonId: string;
            /**
                * Conversation is ended.
                */
            ended: boolean;
            /**
                * Conversation creation timestamp in milliseconds elapsed since January 1, 1970 00:00:00 UTC.
                */
            creationTimestamp: number;
            /**
                * Notification count of this conversation.
                */
            notificationCount: number;
            /**
                * The name of the current recipient of the conversation.
                */
            recipient: string;
            /**
                * Topic of the conversation, may be null if not set.
                */
            topic?: string;
    }
}

declare module 'unblu-floating-js-api/shared/model/invitation' {
    import { InvitationStatus } from "unblu-floating-js-api/shared/model/invitation-status";
    /**
        * An Invitation belongs to a conversation. A Conversation can have multiple invitations.
        * The invitation has different metadata like the status or the token. This information could
        * be further used for example to join a conversation with the provided PIN (token).
        */
    export interface Invitation {
            /**
                * The Id of the invitation.
                */
            id: string;
            /**
                * Status of the the Invitation.
                */
            status: InvitationStatus;
            /**
                * Token for the invitation, the PIN Number.
                */
            token: string;
            /**
                * Expiration timestamp in milliseconds of the invitation elapsed since January 1, 1970 00:00:00 UTC.
                */
            expirationTimestamp: number;
    }
}

declare module 'unblu-floating-js-api/shared/model/person-info' {
    export interface PersonInfo {
        id: string;
        displayName: string;
    }
}

declare module 'unblu-floating-js-api/shared/model/customaction/custom-action-invocation' {
    import { PersonInfo } from "unblu-floating-js-api/shared/model/person-info";
    import { ConversationInfo } from "unblu-floating-js-api/shared/model/conversation-info";
    /**
        * CustomActionInvocation represents an event containing information about the invoked custom action
        */
    export interface CustomActionInvocation {
            /**
                * The invocation ID
                */
            invocationId: string;
            /**
                * The unique key of the invoked custom action
                */
            key: string;
            /**
                * UTC timestamp, in milliseconds, of the custom action invocation
                */
            invocationTimestamp: number;
            /**
                * The person who invoked the custom action
                */
            invokingPerson: PersonInfo;
            /**
                * The conversation the custom action was invoked in
                */
            conversation: ConversationInfo;
    }
}

declare module 'unblu-floating-js-api/internal/internal-api' {
    import { ApiBridge } from 'unblu-floating-js-api/shared/internal/api-bridge';
    import { MetaModule } from 'unblu-floating-js-api/internal/module/meta-module';
    import { GeneralLazyModule } from 'unblu-floating-js-api/internal/module/general-lazy-module';
    import { ConversationModule } from 'unblu-floating-js-api/shared/internal/module/conversation-module';
    import { AgentAvailabilityModule } from 'unblu-floating-js-api/shared/internal/module/agent-availability-module';
    import { GeneralModule } from "unblu-floating-js-api/internal/module/general-module";
    import { Configuration } from "unblu-floating-js-api/unblu-static-api";
    export class InternalApi {
        readonly configuration: Configuration;
        readonly meta: MetaModule;
        readonly general: GeneralModule;
        readonly generalLazy: GeneralLazyModule;
        readonly conversation: ConversationModule;
        readonly agentAvailability: AgentAvailabilityModule;
        constructor(bridge: ApiBridge, configuration: Configuration);
        checkCompatibility(): void;
    }
}

declare module 'unblu-floating-js-api/shared/internal/util/event-emitter' {
    export type Listener = (data?: any) => void;
    export class EventEmitter {
            /**
                * Resets the emitter by removing all registered listeners.
                */
            reset(): void;
            /**
                * Adds an event listeners
                * @param event the event to listen to
                * @param listener the listener to be called.
                */
            on(event: string, listener: Listener): void;
            /**
                * removes a previously registered listener
                * @param event the event
                * @param listener the listener that should be removed.
                * @return `true` if the listener was removed, `false` otherwise.
                */
            off(event: string, listener: any): boolean;
            /**
                * removes all listeners for the given event.
                * @param event the event for which all listeners will be removed.
                */
            offAll(event: string): void;
            /**
                * Checks weather at least one listener exists for a given event.
                * @param event the event to check for
                * @return weather or not any listeners for the given event are registered.
                */
            hasListeners(event: string): boolean;
            /**
                * Returns all events that have at least one listeners registered to them.
                * @return An array containing all events that have at least one listener.
                * If no listeners are registered at all, an empty array will be returned.
                */
            getEventsWithListeners(): string[];
            /**
                * Emits an event dispatching it to all listeners registered for it.
                * @param event the event name.
                * @param data the event data.
                */
            emit(event: string, data?: any): void;
    }
}

declare module 'unblu-floating-js-api/shared/internal/module/agent-availability-module' {
    import { InternalModule } from 'unblu-floating-js-api/shared/internal/module/module';
    import { ApiBridge } from 'unblu-floating-js-api/shared/internal/api-bridge';
    import { AgentAvailabilityState } from 'unblu-floating-js-api/shared/model/agent-availability-state';
    export type AgentAvailabilityEventType = 'availableChange' | 'availabilityChange';
    const enum AgentAvailabilityFunction {
        isAgentAvailable = "isAgentAvailable",
        getAgentAvailabilityState = "getAgentAvailabilityState"
    }
    export class AgentAvailabilityModule extends InternalModule<AgentAvailabilityFunction, AgentAvailabilityEventType> {
        constructor(bridge: ApiBridge);
        isAgentAvailable(): Promise<boolean>;
        getAgentAvailabilityState(): Promise<AgentAvailabilityState>;
    }
    export {};
}

declare module 'unblu-floating-js-api/internal/module/meta-module' {
    import { InternalModule } from 'unblu-floating-js-api/shared/internal/module/module';
    import { ApiBridge } from 'unblu-floating-js-api/shared/internal/api-bridge';
    export type MetaEventType = 'upgraded' | 'deinitializing' | 'deinitialized';
    const enum MetaFunction {
        isUpgraded = "isUpgraded",
        upgrade = "upgrade",
        waitUntilInitialized = "waitUntilInitialized",
        deinitialize = "deinitialize"
    }
    export class MetaModule extends InternalModule<MetaFunction, MetaEventType> {
        constructor(bridge: ApiBridge);
        isUpgraded(): Promise<boolean>;
        upgrade(openUi?: boolean): Promise<boolean>;
        waitUntilInitialized(): Promise<void>;
        deinitialize(): Promise<boolean>;
    }
    export {};
}

declare module 'unblu-floating-js-api/internal/module/general-module' {
    import { IndividualUiState } from "unblu-floating-js-api/model/individualui_state";
    import { BaseGeneralEventType, BaseGeneralFunction, BaseGeneralModule } from "unblu-floating-js-api/shared/internal/module/base-general-module";
    import { ActiveIndividualUiView } from "unblu-floating-js-api/model/individualui_component";
    export type GeneralEventType = BaseGeneralEventType | 'uiStateChange' | 'uiActiveIndividualUiViewChange';
    const enum GeneralFunction {
        toggleIndividualUi = "toggleIndividualUi",
        popoutIndividualUi = "popoutIndividualUi",
        popinIndividualUi = "popinIndividualUi",
        maximizeIndividualUi = "maximizeIndividualUi",
        minimizeIndividualUi = "minimizeIndividualUi",
        openIndividualUi = "openIndividualUi",
        openPinEntryUi = "openPinEntryUi",
        openOverviewUi = "openOverviewUi",
        collapseIndividualUi = "collapseIndividualUi",
        getIndividualUiState = "getIndividualUiState",
        getActiveIndividualUiView = "getActiveIndividualUiView"
    }
    export class GeneralModule extends BaseGeneralModule<GeneralFunction | BaseGeneralFunction, GeneralEventType> {
        toggleIndividualUi(): Promise<void>;
        openPinEntryUi(): Promise<void>;
        openOverviewUi(): Promise<void>;
        popoutIndividualUi(): Promise<void>;
        popinIndividualUi(): Promise<void>;
        maximizeIndividualUi(): Promise<void>;
        minimizeIndividualUi(): Promise<void>;
        openIndividualUi(): Promise<void>;
        collapseIndividualUi(): Promise<void>;
        getIndividualUiState(): Promise<IndividualUiState>;
        getActiveIndividualUiView(): Promise<ActiveIndividualUiView>;
    }
    export {};
}

declare module 'unblu-floating-js-api/shared/internal/initialized-unblu-api' {
    /**
      * @hidden
      */
    export interface InitializedUnbluApi {
        deinitialize(): Promise<void>;
    }
}

declare module 'unblu-floating-js-api/shared/internal/module/conversation-module' {
    import { InternalModule } from 'unblu-floating-js-api/shared/internal/module/module';
    import { ApiBridge } from 'unblu-floating-js-api/shared/internal/api-bridge';
    import { CallState } from 'unblu-floating-js-api/shared/model/call-state';
    import { ConversationState } from 'unblu-floating-js-api/shared/model/conversation-state';
    import { ConnectionState } from 'unblu-floating-js-api/shared/model/connection-state';
    import { Invitation } from "unblu-floating-js-api/shared/model/invitation";
    export interface ConversationCallState {
        conversationId: string;
        callState: CallState;
    }
    export interface ConversationConnectionState {
        conversationId: string;
        connectionState: ConnectionState;
    }
    export interface ConversationWithState {
        conversationId: string;
        conversationState: ConversationState;
    }
    export interface ConversationInvitations {
        conversationId: string;
        invitations: Invitation[];
    }
    export type ConversationEventType = 'connectionStateChange' | 'conversationStateChange' | 'end' | 'close' | 'personChange' | 'callStateChange' | 'invitationsChange' | 'customActionInvocation';
    const enum ConversationFunction {
        getConnectionState = "getConnectionState",
        getConversationState = "getConversationState",
        getCallState = "getCallState",
        startAudioCall = "startAudioCall",
        startVideoCall = "startVideoCall",
        endConversation = "endConversation",
        leaveConversation = "leaveConversation",
        closeConversation = "closeConversation",
        createAnonymousPinInvitation = "createAnonymousPinInvitation",
        createAnonymousEmailInvitation = "createAnonymousEmailInvitation",
        getInvitations = "getInvitations",
        revokeInvitation = "revokeInvitation",
        renewInvitationPin = "renewInvitationPin",
        setVisitorData = "setVisitorData"
    }
    export class ConversationModule extends InternalModule<ConversationFunction, ConversationEventType> {
        constructor(bridge: ApiBridge);
        getConnectionState(conversationId: string): Promise<ConnectionState>;
        getConversationState(conversationId: string): Promise<ConversationState>;
        getCallState(conversationId: string): Promise<CallState>;
        startAudioCall(conversationId: string): Promise<void>;
        startVideoCall(conversationId: string): Promise<void>;
        endConversation(conversationId: string): Promise<void>;
        leaveConversation(conversationId: string): Promise<void>;
        closeConversation(conversationId: string): Promise<void>;
        createAnonymousPinInvitation(conversationId: string): Promise<Invitation>;
        createAnonymousEmailInvitation(conversationId: string, email: String): Promise<Invitation>;
        getInvitations(conversationId: string): Promise<Invitation[]>;
        revokeInvitation(conversationId: string, invitationId: String): Promise<void>;
        renewInvitationPin(conversationId: string, invitationId: String): Promise<Invitation>;
        setVisitorData(visitorData: String): Promise<void>;
    }
    export {};
}

declare module 'unblu-floating-js-api/shared/model/configuration' {
    export interface Configuration {
            /**
                * The API key to use.
                * This is a mandatory configuration.
                *
                * You can retrieve API keys from the Account Configuration interface.
                * This requires the `ADMIN` user role.
                */
            apiKey: string;
            /**
                * The URL of the Unblu server to connect to.
                *
                * @default If not set, the domain of the current page is used.
                */
            serverUrl?: string;
            /**
                * The public path used with {@link serverUrl} to connect to Unblu.
                *
                * @default If not set, '/unblu' is used.
                */
            entryPath?: string;
            /**
                * The locale to use for all Unblu translation texts.
                *
                * @default If not set, the browser's locale will be used.
                */
            locale?: string;
            /**
                * The named area to be used.
                * The named area determines the queue that conversation requests go to, the agent availability, and the configuration.
                *
                * @default If not set, the named area specified in the HTML `meta` element named `unblu:named-area` is used.
                * If no such element is present, the named area associated with the current domain is used.
                */
            namedArea?: string;
            /**
                * The timeout in milliseconds for the Unblu integration to load.
                *
                * @default 30'000 (30 seconds)
                */
            initTimeout?: number;
            /**
                * The access token used to log the user in before initializing Unblu.
                */
            accessToken?: string;
    }
}

declare module 'unblu-floating-js-api/shared/internal/unblu-api-factory' {
    import { ApiState } from "unblu-floating-js-api/shared/api-state";
    import { InitializedUnbluApi } from "unblu-floating-js-api/shared/internal/initialized-unblu-api";
    /**
      * @hidden
      */
    export interface UnbluApiFactory {
        initialize(): Promise<InitializedUnbluApi>;
        getApiState(): ApiState;
    }
}

declare module 'unblu-floating-js-api/shared/internal/api-bridge' {
    import { EventCallback } from 'unblu-floating-js-api/shared/internal/event';
    export class ApiBridge {
            /**
                * instantiates the bridge that links the UNBLU internal API provided by the collaboration server with the UNBLU JS-API
                * @param mountPoint the global unblu object under which the internal API is registered.
                */
            constructor(mountPoint: any, mountName: string);
            waitUntilLoaded(timeout: number, promise?: Promise<void>): Promise<void>;
            checkCompatibility(): void;
            /**
                * Calls an API function of the internal unblu collaboration server API.
                * @param moduleName The module to which the function belongs.
                * @param functionName The function to call.
                * @param args The arguments to pass to the function.
                */
            callApiFunction(moduleName: string, functionName: string, args: any[]): Promise<any>;
            /**
                * Registers a callback for an event emitted by the internal unblu collaboration server API.
                * @param module The module that emits the event.
                * @param event The event name.
                * @param callback The callback which will be called every time the event is emitted.
                */
            on(module: string, event: string, callback: EventCallback): Promise<void>;
            /**
                * Unregisters a callback for an event emitted by the internal unblu collaboration server API.
                * @param module The module that emits the event.
                * @param event The event name.
                * @param callback Optionally callback which will be removed, if none is provided all listeners of the event will be removed.
                */
            off(module: string, event: string, callback?: EventCallback): Promise<void>;
    }
}

declare module 'unblu-floating-js-api/internal/module/general-lazy-module' {
    import { InternalModule } from 'unblu-floating-js-api/shared/internal/module/module';
    import { ApiBridge } from 'unblu-floating-js-api/shared/internal/api-bridge';
    import { PersonInfo } from 'unblu-floating-js-api/shared/model/person-info';
    import { NewConversationInterceptor } from "unblu-floating-js-api/shared/new-conversation-interceptor";
    export type GeneralLazyEventType = '';
    const enum GeneralLazyFunction {
        getNotificationCount = "getNotificationCount",
        getPersonInfo = "getPersonInfo",
        setNewConversationInterceptor = "setNewConversationInterceptor"
    }
    export class GeneralLazyModule extends InternalModule<GeneralLazyFunction, GeneralLazyEventType> {
        constructor(bridge: ApiBridge);
        getNotificationCount(): Promise<number>;
        getPersonInfo(): Promise<PersonInfo>;
        setNewConversationInterceptor(callback: NewConversationInterceptor): Promise<void>;
    }
    export {};
}

declare module 'unblu-floating-js-api/shared/internal/module/module' {
    import { ApiBridge } from 'unblu-floating-js-api/shared/internal/api-bridge';
    import { EventCallback } from 'unblu-floating-js-api/shared/internal/event';
    export class InternalModule<T extends string, E extends string> {
        moduleName: string;
        constructor(bridge: ApiBridge, moduleName: string);
        protected callApiFunction(functionName: T, args: any[]): Promise<any>;
        on(eventName: E, listener: EventCallback): Promise<void>;
        off(eventName: E, listener: EventCallback): Promise<void>;
    }
}

declare module 'unblu-floating-js-api/shared/internal/module/base-general-module' {
    import { ApiBridge } from "unblu-floating-js-api/shared/internal/api-bridge";
    import { InternalModule } from "unblu-floating-js-api/shared/internal/module/module";
    import { NewConversationInterceptor } from "unblu-floating-js-api/shared/new-conversation-interceptor";
    import { ConversationType } from "unblu-floating-js-api/shared/model/conversation-type";
    import { PersonInfo } from "unblu-floating-js-api/shared/model/person-info";
    import { ConversationInfo } from "unblu-floating-js-api/shared/model/conversation-info";
    import { ConversationRecipient } from "unblu-floating-js-api/shared/model/conversation-recipient";
    export type BaseGeneralEventType = 'activeConversationChange' | 'conversationsChange' | 'notificationCountChange' | 'personChange' | 'personActivity';
    export enum BaseGeneralFunction {
        startConversation = "startConversation",
        setNewConversationInterceptor = "setNewConversationInterceptor",
        joinConversation = "joinConversation",
        openConversation = "openConversation",
        getActiveConversation = "getActiveConversation",
        getConversations = "getConversations",
        getNotificationCount = "getNotificationCount",
        getPersonInfo = "getPersonInfo",
        setPersonNickname = "setPersonNickname"
    }
    export class BaseGeneralModule<T extends string | BaseGeneralFunction, E extends BaseGeneralEventType | string> extends InternalModule<BaseGeneralFunction | T, E> {
        constructor(bridge: ApiBridge);
        startConversation(type: ConversationType, visitorName?: string, visitorData?: string, recipient?: ConversationRecipient): Promise<string>;
        setNewConversationInterceptor(callback: NewConversationInterceptor): Promise<void>;
        joinConversation(pin: string, visitorName?: string): Promise<string>;
        openConversation(conversationId: string): Promise<void>;
        getActiveConversation(): Promise<string | null>;
        getConversations(): Promise<ConversationInfo[]>;
        getNotificationCount(): Promise<number>;
        getPersonInfo(): Promise<PersonInfo>;
        setPersonNickname(nickname: string): Promise<void>;
    }
}

declare module 'unblu-floating-js-api/shared/internal/event' {
    export interface Event<T> {
        module: string;
        name: string;
        data: T;
    }
    export type EventCallback = (event: Event<any>) => void;
}

